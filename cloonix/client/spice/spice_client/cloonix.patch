diff -Naur spice-gtk/meson.build tainted_spice/meson.build
--- spice-gtk/meson.build	2024-04-12 23:36:08.000000000 +0200
+++ tainted_spice/meson.build	2024-04-12 23:56:01.970815812 +0200
@@ -5,7 +5,8 @@
          version : run_command('build-aux/git-version-gen', '@0@/.tarball-version'.format(meson.project_source_root()), check : true).stdout().strip(),
          license : 'LGPLv2.1',
          meson_version : '>= 0.56',
-         default_options : ['buildtype=debugoptimized',
+         default_options : ['default_library=static',
+                            'buildtype=debugoptimized',
                             'warning_level=2'])
 
 meson.add_dist_script('build-aux/meson-dist', meson.project_version(), meson.project_source_root())
@@ -22,6 +23,7 @@
 spice_gtk_includedir = spice_gtk_prefix / get_option('includedir')
 spice_gtk_global_cflags = ['-DHAVE_CONFIG_H',
                            '-DSPICE_COMPILATION',
+                           '-DSPICE_DISABLE_DEPRECATED',
                            '-DG_LOG_DOMAIN="GSpice"',
                            '-Wno-sign-compare',
                            '-Wno-unused-parameter',
@@ -42,6 +44,7 @@
 #
 spice_common = subproject('spice-common',
                           default_options : [
+                            'default_library=static',
                             'generate-code=client',
                             'spice-protocol-version=@0@'.format(spice_protocol_version),
                           ])
@@ -225,8 +228,8 @@
 spice_gtk_has_usbredir = false
 usbredir_version = '0.7.1'
 usbredir_version_info = '>= @0@'.format(usbredir_version)
-d1 = dependency('libusbredirparser-0.5', version: usbredir_version_info, required : get_option('usbredir'))
-d2 = dependency('libusbredirhost', version: usbredir_version_info, required : get_option('usbredir'))
+d1 = dependency('libcloonix-usbredirparser-0.5', version: usbredir_version_info, required : get_option('usbredir'))
+d2 = dependency('libcloonix-usbredirhost', version: usbredir_version_info, required : get_option('usbredir'))
 d3 = dependency('libusb-1.0', version : '>= 1.0.21', required : get_option('usbredir'))
 summary_info += {'usbredir': d1.found() and d2.found() and d3.found()}
 if d1.found() and d2.found() and d3.found()
@@ -437,15 +440,15 @@
 subdir('src')
 subdir('tools')
 subdir('tests')
-if build_machine.system() == 'windows'
-  message('Disabling gtk-doc while building on Windows')
-else
-  d = find_program('gtkdoc-scan', required : get_option('gtk_doc'))
-  if d.found()
-    subdir('doc')
-  endif
-  summary_info += {'gtk_doc': d.found()}
-endif
+# if build_machine.system() == 'windows'
+#   message('Disabling gtk-doc while building on Windows')
+# else
+#   d = find_program('gtkdoc-scan', required : get_option('gtk_doc'))
+#   if d.found()
+#     subdir('doc')
+#   endif
+#   summary_info += {'gtk_doc': d.found()}
+# endif
 subdir('data')
 subdir('man')
 subdir('po')
diff -Naur spice-gtk/src/channel-main.c tainted_spice/src/channel-main.c
--- spice-gtk/src/channel-main.c	2024-04-12 23:36:08.000000000 +0200
+++ tainted_spice/src/channel-main.c	2024-04-12 23:56:01.970815812 +0200
@@ -2799,6 +2799,9 @@
 {
     SpiceMainChannelPrivate *c;
 
+    if (channel == NULL)
+      return;
+
     g_return_if_fail(channel != NULL);
     g_return_if_fail(SPICE_IS_MAIN_CHANNEL(channel));
     g_return_if_fail(x >= 0);
@@ -3146,6 +3149,8 @@
                                                gboolean update)
 {
     SpiceDisplayState display_state = enabled ? DISPLAY_ENABLED : DISPLAY_DISABLED;
+    if (channel == NULL)
+      return;
     g_return_if_fail(channel != NULL);
     g_return_if_fail(SPICE_IS_MAIN_CHANNEL(channel));
     g_return_if_fail(id >= -1);
diff -Naur spice-gtk/src/cloon.c tainted_spice/src/cloon.c
--- spice-gtk/src/cloon.c	1970-01-01 01:00:00.000000000 +0100
+++ tainted_spice/src/cloon.c	2024-04-12 23:56:01.970815812 +0200
@@ -0,0 +1,609 @@
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <syslog.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <sys/stat.h>
+
+#include <errno.h>
+
+#include <glib-object.h>
+#include <gio/gio.h>
+
+#include "cloon.h"
+#include "hmac_cipher.h"
+
+
+typedef struct t_rx_pktbuf
+{
+  char buf[MAX_DOORWAYS_BUF_LEN];
+  int  offset;
+  int  idx_hmac;
+  int  dido_llid;
+  int  size_req;
+  int  paylen;
+  int  paylen_given;
+  int  type;
+  int  val;
+  int  nb_pkt_rx;
+  char *payload;
+} t_rx_pktbuf;
+
+
+
+typedef struct t_sock_ctx
+{
+  GSocket *gsock;
+  int sock;
+  int nb_tx_pkt;
+  t_rx_pktbuf rx_pktbuf;
+} t_sock_ctx;
+
+static t_sock_ctx *g_sock_ctx[MAX_FD_NUMBER_CTX];
+
+
+/*****************************************************************************/
+static int test_file_is_socket(char *path)
+{
+  int result = -1;
+  struct stat stat_file;
+  if (!stat(path, &stat_file))
+    {
+    if (S_ISSOCK(stat_file.st_mode))
+      result = 0;
+    }
+  return result;
+}
+/*---------------------------------------------------------------------------*/
+
+uint64_t cloonix_get_msec(void)
+{
+  return 0;
+}
+/****************************************************************************/
+static int tst_port(char *str_port, int *port)
+{
+  int result = 0;
+  unsigned long val;
+  char *endptr;
+  val = strtoul(str_port, &endptr, 10);
+  if ((endptr == NULL)||(endptr[0] != 0))
+    result = -1;
+  else
+    {
+    if ((val < 1) || (val > 65535))
+      result = -1;
+    *port = (int) val;
+    }
+  return result;
+}
+/*--------------------------------------------------------------------------*/
+
+/*****************************************************************************/
+int get_address_from_param(char *param, char *ip, int *port)
+{
+  char pm[100];
+  int result = 0;
+  char *ptr_ip, *ptr_port;
+  if (strlen(param) >= 100)
+    KOUT("param LENGTH Problem");
+  else
+    {
+    memset(pm, 0, 100);
+    memset(ip, 0, 100);
+    strncpy(pm, param, 100-1);
+    ptr_ip = pm;
+    ptr_port = strchr(pm, ':');
+    if (ptr_port)
+      {
+      result = 1;
+      *ptr_port = 0;
+      ptr_port++;
+      strncpy(ip, ptr_ip, 100);
+      if (tst_port(ptr_port, port))
+        KOUT("PORT param Problem %s", param);
+      }
+    else
+      {
+      if (test_file_is_socket(param))
+        KOUT("Not unix: %s", param);
+      }
+    }
+  return result;
+}
+/*---------------------------------------------------------------------------*/
+
+/****************************************************************************/
+static void alloc_sock_ctx(GSocket *gsock, int sock)
+{
+  int fd_sock = g_socket_get_fd(gsock);
+  if (sock != fd_sock)
+    KOUT("%d %d", sock, fd_sock);
+  if (g_sock_ctx[sock])
+    KOUT(" ");
+  g_sock_ctx[sock] = (t_sock_ctx *) malloc(sizeof(t_sock_ctx));
+  memset(g_sock_ctx[sock], 0, sizeof(t_sock_ctx));
+  g_sock_ctx[sock]->gsock = gsock;
+  g_sock_ctx[sock]->sock = sock;
+  g_sock_ctx[sock]->nb_tx_pkt = 1;
+  g_sock_ctx[sock]->rx_pktbuf.nb_pkt_rx = 1;
+}
+/*--------------------------------------------------------------------------*/
+
+/****************************************************************************/
+static t_sock_ctx *get_sock_ctx(int sock)
+{
+  return g_sock_ctx[sock];
+}
+/*--------------------------------------------------------------------------*/
+
+
+/****************************************************************************/
+static void set_hmac_password(int i, char *tx, int len, char *payload)
+{
+  int j, idx = i;
+  char *md = compute_msg_digest(len, payload);
+  for (j=0; j<MSG_DIGEST_LEN; j++)
+    tx[idx++] = md[j];
+}
+/*--------------------------------------------------------------------------*/
+
+/****************************************************************************/
+static int check_hmac_password(int i, char *rx, int len, char *payload)
+{
+  int j, k, idx, result = 0;
+  char *md = compute_msg_digest(len, payload);
+  idx = i;
+  for (j=0; j<MSG_DIGEST_LEN; j++)
+    {
+    k = idx++;
+    if (rx[k] != md[j])
+      {
+      result = -1;
+      break;
+      }
+    }
+  return result;
+}
+/*--------------------------------------------------------------------------*/
+
+
+/****************************************************************************/
+static void sock_header_set_info(char *tx,
+                                 int llid, int len, int type, int val,
+                                 int nb_pkt, char **ntx)
+{
+  int idx_hmac, i = 0;
+
+  tx[i++] = 0xCA & 0xFF;
+  tx[i++] = 0xFE & 0xFF;
+
+  tx[i++] = ((llid & 0xFF00) >> 8) & 0xFF;
+  tx[i++] = llid & 0xFF;
+  tx[i++] = ((len & 0xFF000000) >> 24) & 0xFF;
+  tx[i++] = ((len & 0xFF0000) >> 16) & 0xFF;
+  tx[i++] = ((len & 0xFF00) >> 8) & 0xFF;
+  tx[i++] = len & 0xFF;
+  tx[i++] = ((type & 0xFF00) >> 8) & 0xFF;
+  tx[i++] = type & 0xFF;
+  tx[i++] = ((val & 0xFF00) >> 8) & 0xFF;
+  tx[i++] = val & 0xFF;
+  tx[i++] = ((nb_pkt & 0xFF00) >> 8) & 0xFF;
+  tx[i++] = nb_pkt & 0xFF;
+  idx_hmac = i;
+  i += MSG_DIGEST_LEN;
+  tx[i++] = 0xDE & 0xFF;
+  tx[i++] = 0xCA & 0xFF;
+
+  *ntx = &(tx[i++]);
+  set_hmac_password(idx_hmac, tx, len, *ntx);
+}
+/*--------------------------------------------------------------------------*/
+
+
+/****************************************************************************/
+static int sock_header_get_info(char *rx,
+                                 int *llid, int *len, int *type, int *val,
+                                 int *nb_pkt, char **nrx)
+{
+  int idx_hmac, i = 0, result=0;
+  if ((rx[i++] & 0xFF) != 0xCA)
+    {
+    for (i=0; i<16; i++)
+      KERR("ERROR  %02X", (unsigned int)(rx[i] & 0xFF));
+    result = -1;
+    }
+  else if ((rx[i++] & 0xFF) != 0xFE)
+    {
+    for (i=0; i<16; i++)
+      KERR("ERROR  %02X", (unsigned int)(rx[i] & 0xFF));
+    result = -1;
+    }
+  else
+    {
+    *llid = ((rx[i] & 0xFF) << 8) + (rx[i+1] & 0xFF);
+    i += 2; 
+    *len  = ((rx[i] & 0xFF) << 24) + ((rx[i+1] & 0xFF) << 16);
+    i += 2;
+    *len  += ((rx[i] & 0xFF) << 8) + (rx[i+1] & 0xFF);
+    i += 2; 
+    *type = ((rx[i] & 0xFF) << 8) + (rx[i+1] & 0xFF);
+    i += 2; 
+    *val  = ((rx[i] & 0xFF) << 8) + (rx[i+1] & 0xFF);
+    i += 2;  
+    *nb_pkt  = ((rx[i] & 0xFF) << 8) + (rx[i+1] & 0xFF);
+    i += 2;
+    idx_hmac = i;
+    i += MSG_DIGEST_LEN; 
+    if ((rx[i++] & 0xFF) != 0xDE)
+      {
+      KERR("ERROR %02X", (unsigned int) (rx[i-1]));
+      result = -1;
+      }
+    else if ((rx[i++] & 0xFF) != 0xCA)
+      {
+      KERR("ERROR %02X", (unsigned int) (rx[i-1]));
+      result = -1;
+      }
+    else
+      {
+      result = idx_hmac;
+      *nrx  = &(rx[i++]);
+      }
+    }
+  return result;
+}
+/*--------------------------------------------------------------------------*/
+
+/****************************************************************************/
+static int check_extract_rx(char *rx, int expect_val, int expect_pkt, 
+                            int *len, char **payload) 
+{
+  int idx_hmac, type, llid, val, pkt, result = -1;
+  idx_hmac = sock_header_get_info(rx, &llid, len, &type, &val, &pkt, payload);
+  if (idx_hmac != -1)
+    {
+    if (type != doors_type_spice)
+      KERR("ERROR %d", type);
+    else if (val != expect_val)
+      KERR("ERROR %d %d", val, expect_val);
+    else if (pkt != expect_pkt)
+      {
+      result = 0;
+      KERR("ERROR %d %d", pkt, expect_pkt);
+      }
+    else if (idx_hmac != 14)
+      KOUT("ERROR %d", idx_hmac); 
+    else
+      result = 0;
+    }
+  return result;
+}
+/*--------------------------------------------------------------------------*/
+
+/****************************************************************************/
+static int rx_first_msg(int sock, int *dlen, char **drx)
+{
+  char rx[DOORWAYS_HEADER_SIZE + 3];
+  int len, result = -1;
+  fd_set infd;
+  FD_ZERO(&infd);
+  FD_SET(sock, &infd);
+  result = select(sock + 1, &infd, NULL, NULL, NULL);
+  if ( result < 0 )
+    KOUT(" ");
+  else if (FD_ISSET(sock, &infd))
+    {
+    len = read(sock, rx, DOORWAYS_HEADER_SIZE + 3);
+    if (len != DOORWAYS_HEADER_SIZE + 3)
+      KERR("ERROR %d %d", len, DOORWAYS_HEADER_SIZE + 3);
+    else
+      {
+      result = check_extract_rx(rx, doors_val_link_ok, 1, dlen, drx);
+      if (result)
+        KOUT(" ");
+      result = check_hmac_password(14, rx, *dlen, *drx);
+      if (result)
+        KOUT("BAD PASSWORD");
+      }
+    }
+  else
+    KOUT(" ");
+  return result;
+}
+/*--------------------------------------------------------------------------*/
+
+/****************************************************************************/
+static int tx_header(int val, int len, char *buf, int nb_pkt_tx)
+{
+  char *payload;
+  int tot_len = len + DOORWAYS_HEADER_SIZE;
+  sock_header_set_info(buf, 0, len, 
+                       doors_type_spice, val,
+                       nb_pkt_tx, &payload);
+  if (payload != buf + DOORWAYS_HEADER_SIZE)
+    KOUT("%p %p", payload, buf);
+  return tot_len;
+}
+/*---------------------------------------------------------------------------*/
+
+/****************************************************************************/
+static int rx_pktbuf_fill(t_sock_ctx *ctx, t_rx_pktbuf *rx_pktbuf, 
+                          GError **error)
+{
+  int headsize = DOORWAYS_HEADER_SIZE;
+  int result, len_desired, len_avail;
+  if (rx_pktbuf->offset < headsize)
+    {
+    if (rx_pktbuf->paylen != 0)
+      KOUT(" ");
+    if (rx_pktbuf->payload)
+      KOUT(" ");
+    len_desired = headsize - rx_pktbuf->offset;
+    result = 1;
+    }
+  else
+    {
+    if (rx_pktbuf->paylen <= 0)
+      KOUT(" ");
+    if (!rx_pktbuf->payload)
+      KOUT(" ");
+    len_desired = headsize + rx_pktbuf->paylen - rx_pktbuf->offset;
+    if (len_desired > rx_pktbuf->size_req)
+      len_desired = rx_pktbuf->size_req;
+    result = 3;
+    }
+  if (len_desired + rx_pktbuf->offset > MAX_DOORWAYS_BUF_LEN)
+    KOUT("%d %d", len_desired, rx_pktbuf->offset);
+  len_avail = g_socket_receive(ctx->gsock, 
+                               rx_pktbuf->buf + rx_pktbuf->offset, 
+                               len_desired, NULL, error);
+  if (len_avail > 0)
+    {
+    rx_pktbuf->offset += len_avail;
+    if ((result == 1) && (len_desired != len_avail))
+      result = 2; 
+    if ((result == 3) && (len_avail > 0))
+      result = 5; 
+    }
+  else
+    result = -1;
+  return result;
+}
+/*--------------------------------------------------------------------------*/
+
+/****************************************************************************/
+static int rx_pktbuf_get_paylen(t_rx_pktbuf *rx_pktbuf)
+{
+  int nb_pkt, result = 0;
+  rx_pktbuf->idx_hmac = sock_header_get_info(rx_pktbuf->buf,
+                                             &(rx_pktbuf->dido_llid),
+                                             &(rx_pktbuf->paylen),
+                                             &(rx_pktbuf->type),
+                                             &(rx_pktbuf->val),
+                                             &(nb_pkt),
+                                             &(rx_pktbuf->payload));
+  if (rx_pktbuf->idx_hmac == -1)
+    {
+    KOUT(" ");
+    result = -1;
+    rx_pktbuf->offset = 0;
+    rx_pktbuf->paylen = 0;
+    rx_pktbuf->payload = NULL;
+    rx_pktbuf->dido_llid = 0;
+    rx_pktbuf->type = 0;
+    rx_pktbuf->val = 0;
+    }
+  else
+    {
+    if ((nb_pkt-1) != rx_pktbuf->nb_pkt_rx)
+      {
+      KERR("ERROR %d %d", nb_pkt, rx_pktbuf->nb_pkt_rx);
+      result = -1;
+      }
+    if (nb_pkt == 0xFFFF)
+      rx_pktbuf->nb_pkt_rx = 0;
+    else
+      rx_pktbuf->nb_pkt_rx = nb_pkt;
+    }
+  return result;
+}
+/*--------------------------------------------------------------------------*/
+
+/****************************************************************************/
+static int rx_doorways(t_sock_ctx *ctx, t_rx_pktbuf *rx_pktbuf, GError **error)
+{
+  int res;
+  int headsize = DOORWAYS_HEADER_SIZE;
+
+  if ((rx_pktbuf->paylen > 0) && 
+      (rx_pktbuf->offset == rx_pktbuf->paylen + headsize) &&
+      (rx_pktbuf->paylen_given < rx_pktbuf->paylen)) 
+    {
+    res = 5;
+    }
+  else
+    {
+    res = rx_pktbuf_fill(ctx, rx_pktbuf, error);
+    if (res == 1)
+      {
+      rx_pktbuf_get_paylen(rx_pktbuf);
+      res = rx_pktbuf_fill(ctx, rx_pktbuf, error);
+      }
+    }
+
+  if (res == 5)
+    {
+    if (!rx_pktbuf->payload)
+      KOUT(" ");
+    if (rx_pktbuf->paylen <= 0)
+      KOUT(" ");
+    if (rx_pktbuf->idx_hmac != 14)
+      KOUT("%d", rx_pktbuf->idx_hmac);
+    if (rx_pktbuf->type != doors_type_spice)
+      KOUT("%d %d", rx_pktbuf->type, doors_type_spice);
+    if (rx_pktbuf->val != doors_val_none)
+      KOUT("%d %d", rx_pktbuf->val, doors_val_none);
+    if (rx_pktbuf->offset == rx_pktbuf->paylen + headsize)
+      {
+      if (check_hmac_password(rx_pktbuf->idx_hmac, rx_pktbuf->buf,
+                            rx_pktbuf->paylen, rx_pktbuf->payload))
+        KOUT("BAD PASSWORD: %d %d %d", rx_pktbuf->paylen, 
+                                       rx_pktbuf->offset, 
+                                       rx_pktbuf->paylen_given);
+      }
+    }
+  return res;
+}
+/*--------------------------------------------------------------------------*/
+
+/****************************************************************************/
+static int tx_doorways(t_sock_ctx *ctx, int len, char *buf, GError **error)
+{
+  int ret, tot_len, result = 0;
+  char *msg_buf;
+  int max = MAX_DOORWAYS_BUF_LEN - DOORWAYS_HEADER_SIZE;
+  if ((len<0) || (len >= max))
+    KOUT("%d %d", len, max);
+  if (len > 0)
+    {
+    if (ctx->nb_tx_pkt == 0xFFFF)
+      ctx->nb_tx_pkt = 1;
+    else
+      ctx->nb_tx_pkt += 1;
+    msg_buf = (char *) malloc(len + DOORWAYS_HEADER_SIZE);
+    memcpy(msg_buf + DOORWAYS_HEADER_SIZE, buf, len);
+    tot_len = tx_header(doors_val_none, len, msg_buf, ctx->nb_tx_pkt);
+    ret = g_socket_send(ctx->gsock, msg_buf, tot_len, NULL, error);
+    if (ret <= 0)
+      result = ret;
+    else if (ret != tot_len)
+      KOUT("%d %d", ret, tot_len);
+    else 
+      result = len; 
+    free(msg_buf);
+    }
+  return result;
+}
+/*---------------------------------------------------------------------------*/
+
+/****************************************************************************/
+void cloonix_preliminaries(char *password, GSocket *gsock, int sock, char *spice_sock) 
+{
+  char buf[300+DOORWAYS_HEADER_SIZE];
+  int headsize = DOORWAYS_HEADER_SIZE;
+  int len = strlen(spice_sock) + 1;
+  int tot_len, tx_len, dlen;
+  char *drx;
+  if (!password)
+    KOUT(" ");
+  if (strlen(password) < 2)
+    KOUT("%d %s", (int) strlen(password), password);
+  if (strlen(password) >= MSG_DIGEST_LEN)
+    KOUT("%d %s", (int) strlen(password), password);
+  cipher_myinit(password);
+  if (sock >= MAX_FD_NUMBER_CTX)
+    KOUT("%d %d", sock, MAX_FD_NUMBER_CTX);
+  memset(buf, 0, 300);
+  strncpy(buf+headsize, spice_sock, 300-1); 
+  tot_len = tx_header(doors_val_init_link, len, buf, 1);
+  tx_len = write(sock, buf, tot_len); 
+  if (tx_len != tot_len)
+    KERR("ERROR tx : %d %d", tx_len, tot_len);
+  if (!rx_first_msg(sock, &dlen, &drx))
+    {
+    alloc_sock_ctx(gsock, sock);
+    }
+  else
+    KERR("ERROR");
+}
+
+
+
+/****************************************************************************/
+gssize cloonix_g_socket_send (GSocket *socket, const gchar *buffer, 
+                              gsize size, GCancellable *cancellable, 
+                              GError **error)
+{
+  gssize ret;
+  int fd_sock;
+  t_sock_ctx *ctx;
+  fd_sock = g_socket_get_fd(socket);
+  ctx = get_sock_ctx(fd_sock);
+  if (!ctx)
+    KOUT(" ");
+  ret = tx_doorways(ctx, (int) size, (char *) buffer, error);
+  return ret;
+}
+/*--------------------------------------------------------------------------*/
+
+
+/****************************************************************************/
+gssize cloonix_g_socket_receive(GSocket *socket, gchar *buffer, gsize size,
+                                GCancellable *cancellable, GError **error)
+{
+  int headsize = DOORWAYS_HEADER_SIZE;
+  int fd_sock, result, len_to_give, left_to_give;
+  t_sock_ctx *ctx;
+  t_rx_pktbuf *rx_pktbuf;
+  fd_sock = g_socket_get_fd(socket);
+  ctx = get_sock_ctx(fd_sock);
+  if (!ctx)
+    KOUT(" ");
+  if (socket != ctx->gsock)
+    KOUT(" ");
+  rx_pktbuf = &(ctx->rx_pktbuf);
+  rx_pktbuf->size_req = size;
+  result = rx_doorways(ctx, rx_pktbuf, error);
+  if (result == 2)
+    {
+    result = -1;
+    g_set_error (error, G_IO_ERROR, G_IO_ERROR_WOULD_BLOCK, "fd would block");
+    }
+  else if (result != -1)
+    { 
+    if (result != 5)
+      KERR("ERROR %d %d %d %d", result, rx_pktbuf->paylen,
+                                rx_pktbuf->offset, rx_pktbuf->paylen_given);
+    else
+      {
+      left_to_give = rx_pktbuf->offset - headsize - rx_pktbuf->paylen_given; 
+      if (left_to_give < 0) 
+        KOUT("%d", left_to_give);
+      if (size < left_to_give)
+        len_to_give = size;
+      else
+        len_to_give = left_to_give;
+      result = len_to_give;
+      if (result == 0)
+        {
+        result = -1;
+        g_set_error (error, G_IO_ERROR,G_IO_ERROR_WOULD_BLOCK,"fd would block");
+        KERR("ERROR %d %d %d", rx_pktbuf->paylen, rx_pktbuf->offset, 
+                         rx_pktbuf->paylen_given);
+        }
+      else
+        {
+        memcpy(buffer, rx_pktbuf->payload + rx_pktbuf->paylen_given, len_to_give);
+        rx_pktbuf->paylen_given += len_to_give;
+        if (rx_pktbuf->paylen_given == rx_pktbuf->paylen)
+          {
+          rx_pktbuf->offset = 0;
+          rx_pktbuf->paylen = 0;
+          rx_pktbuf->paylen_given = 0;
+          rx_pktbuf->payload = NULL;
+          rx_pktbuf->dido_llid = 0;
+          rx_pktbuf->type = 0;
+          rx_pktbuf->val = 0;
+          }
+        }
+      }
+    }
+  return result;
+}
+/*--------------------------------------------------------------------------*/
+
+
+
diff -Naur spice-gtk/src/cloon.h tainted_spice/src/cloon.h
--- spice-gtk/src/cloon.h	1970-01-01 01:00:00.000000000 +0100
+++ tainted_spice/src/cloon.h	2024-04-12 23:56:01.970815812 +0200
@@ -0,0 +1,22 @@
+
+
+#include <syslog.h>
+#include "../../../../common/glob_include/glob_common.h"
+
+
+#define MAX_FD_NUMBER_CTX  100
+
+
+/*--------------------------------------------------------------------------*/
+void cloonix_preliminaries(char *password, GSocket *gsock, int sock, char *spice_sock);
+/*--------------------------------------------------------------------------*/
+gssize cloonix_g_socket_send (GSocket *socket, const gchar *buffer,
+                              gsize size, GCancellable *cancellable,
+                              GError **error);
+/*--------------------------------------------------------------------------*/
+gssize cloonix_g_socket_receive(GSocket *socket, gchar *buffer, gsize size,
+                                GCancellable *cancellable, GError **error);
+/*--------------------------------------------------------------------------*/
+int get_address_from_param(char *param, char *ip, int *port);
+/*--------------------------------------------------------------------------*/
+
diff -Naur spice-gtk/src/hmac_cipher.c tainted_spice/src/hmac_cipher.c
--- spice-gtk/src/hmac_cipher.c	1970-01-01 01:00:00.000000000 +0100
+++ tainted_spice/src/hmac_cipher.c	2024-04-12 23:56:01.970815812 +0200
@@ -0,0 +1,144 @@
+/*****************************************************************************/
+/*    Copyright (C) 2006-2022 clownix@clownix.net License AGPL-3             */
+/*                                                                           */
+/*  This program is free software: you can redistribute it and/or modify     */
+/*  it under the terms of the GNU Affero General Public License as           */
+/*  published by the Free Software Foundation, either version 3 of the       */
+/*  License, or (at your option) any later version.                          */
+/*                                                                           */
+/*  This program is distributed in the hope that it will be useful,          */
+/*  but WITHOUT ANY WARRANTY; without even the implied warranty of           */
+/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
+/*  GNU Affero General Public License for more details.a                     */
+/*                                                                           */
+/*  You should have received a copy of the GNU Affero General Public License */
+/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.    */
+/*                                                                           */
+/*****************************************************************************/
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <errno.h>
+
+#include <openssl/hmac.h>
+#include <openssl/evp.h>
+#include "hmac_cipher.h"
+
+#include <syslog.h>
+#define KOUT(format, a...)                               \
+ do {                                                    \
+    printf("\n%s %s line:%d   " format,         \
+    __FILE__,__FUNCTION__,__LINE__, ## a);               \
+    syslog(LOG_ERR, "%s %s line:%d   " format, \
+    __FILE__,__FUNCTION__,__LINE__, ## a);               \
+    exit(-1);                                            \
+    } while (0)
+
+static unsigned char glob_key[MSG_DIGEST_LEN];
+static const EVP_MD *md_hmac_sha;
+static EVP_CIPHER_CTX *cipher_ctx;
+
+/*****************************************************************************/
+char *compute_msg_digest(int len, char *data)
+{
+  unsigned char *md;
+  unsigned int md_len;
+  md = HMAC(md_hmac_sha, ( unsigned char *)glob_key, MSG_DIGEST_LEN, 
+            (const unsigned char *) data, (unsigned int) len, NULL, &md_len);
+  if (md_len != MSG_DIGEST_LEN)
+    KOUT("%d %d", (int) md_len, (int) MSG_DIGEST_LEN);
+  return (char *)md;
+}
+/*---------------------------------------------------------------------------*/
+
+/*****************************************************************************/
+static int cipher( int do_encrypt, unsigned char *iv, 
+            int inlen, unsigned char *inbuf,
+            unsigned char *outbuf)
+{
+  int len, tot_len = 0;
+  EVP_CIPHER_CTX_init(cipher_ctx);
+  EVP_CipherInit_ex(cipher_ctx, EVP_aes_256_cbc(), NULL, 
+                    glob_key, iv, do_encrypt);
+  EVP_CIPHER_CTX_set_key_length(cipher_ctx, MSG_DIGEST_LEN);
+  if (EVP_CipherUpdate(cipher_ctx, outbuf, &len, inbuf, inlen))
+    {
+    tot_len += len;
+    if (EVP_CipherFinal_ex(cipher_ctx, outbuf+tot_len, &len))
+      tot_len += len;
+    }
+  EVP_CIPHER_CTX_cleanup(cipher_ctx);
+  return tot_len;
+}
+/*---------------------------------------------------------------------------*/
+
+/*****************************************************************************/
+int hmac_extract_and_decipher(int len, char *buf, char **outbuf)
+{
+  int outlen = 0;
+  char *md = buf;
+  char *md_check;
+  *outbuf = NULL;
+  if (len > MSG_DIGEST_LEN)
+    {
+    *outbuf = (char *) malloc(len);
+    outlen = cipher( 0, (unsigned char *) md, len-MSG_DIGEST_LEN, 
+    (unsigned char *) (buf+MSG_DIGEST_LEN), (unsigned char *) (*outbuf));   
+    if (!outlen)
+      {
+      free(*outbuf);
+      *outbuf = NULL;
+      }
+    else
+      {
+      md_check = compute_msg_digest(outlen, *outbuf);
+      if (memcmp(md_check, md, MSG_DIGEST_LEN))
+        {
+        free(*outbuf);
+        *outbuf = NULL;
+        outlen = 0;
+        }
+      }
+    }
+  return outlen;
+}
+/*---------------------------------------------------------------------------*/
+
+/*****************************************************************************/
+int hmac_insert_and_cipher(int len, char *buf, char **outbuf)
+{
+  int outlen, max_len;
+  char *md = compute_msg_digest(len, buf);
+  max_len = len + 2*MSG_DIGEST_LEN;
+  *outbuf = (char *) malloc(max_len);
+  memcpy(*outbuf, md, MSG_DIGEST_LEN);
+  outlen = cipher( 1, (unsigned char *) md, len, 
+           (unsigned char *) buf, (unsigned char *) (*outbuf+MSG_DIGEST_LEN)); 
+  if (!outlen)
+    {
+    free(*outbuf);
+    *outbuf = NULL;
+    }
+  else
+    outlen += MSG_DIGEST_LEN;
+  return outlen;
+}
+/*---------------------------------------------------------------------------*/
+
+/*****************************************************************************/
+void cipher_myinit(char *key)
+{
+  cipher_ctx = EVP_CIPHER_CTX_new();
+  if ((strlen(key) < 2) || (strlen(key) >= MSG_DIGEST_LEN))
+    KOUT("%d %s", (int) (strlen(key)), key);
+  memset(glob_key, 0, MSG_DIGEST_LEN);
+  memcpy(glob_key, key, strlen(key));
+  OpenSSL_add_all_digests();
+  md_hmac_sha = EVP_get_digestbyname("SHA256");
+  if(!md_hmac_sha)
+    KOUT("Unknown message digest \"SHA256\"");
+}
+/*---------------------------------------------------------------------------*/
+
+
diff -Naur spice-gtk/src/hmac_cipher.h tainted_spice/src/hmac_cipher.h
--- spice-gtk/src/hmac_cipher.h	1970-01-01 01:00:00.000000000 +0100
+++ tainted_spice/src/hmac_cipher.h	2024-04-12 23:56:01.970815812 +0200
@@ -0,0 +1,28 @@
+/*****************************************************************************/
+/*    Copyright (C)  2006-2022    Cloon,    <clownix@clownix.net>          */
+/*****************************************************************************/
+/*                                                                           */
+/*    This program is free software: you can redistribute it and/or modify   */
+/*    it under the terms of the GNU General Public License as published by   */
+/*    the Free Software Foundation, either version 3 of the License, or      */
+/*    (at your option) any later version.                                    */
+/*                                                                           */
+/*    This program is distributed in the hope that it will be useful,        */
+/*    but WITHOUT ANY WARRANTY; without even the implied warranty of         */
+/*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          */
+/*    GNU General Public License for more details.                           */
+/*                                                                           */
+/*    You should have received a copy of the GNU General Public License      */
+/*    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+/*                                                                           */
+/*****************************************************************************/
+#define MSG_DIGEST_LEN 32
+#define DOORWAYS_HEADER_SIZE (16+MSG_DIGEST_LEN)
+char *compute_msg_digest(int len, char *data);
+int hmac_extract_and_decipher(int len, char *buf, char **outbuf);
+int hmac_insert_and_cipher(int len, char *buf, char **outbuf);
+void cipher_myinit(char *key);
+/*---------------------------------------------------------------------------*/
+
+
+
diff -Naur spice-gtk/src/meson.build tainted_spice/src/meson.build
--- spice-gtk/src/meson.build	2024-04-12 23:36:08.000000000 +0200
+++ tainted_spice/src/meson.build	2024-04-12 23:56:01.970815812 +0200
@@ -130,6 +130,8 @@
   'spice-client.c',
   'spice-option.c',
   'spice-session.c',
+  'cloon.c',
+  'hmac_cipher.c',
   'spice-util.c',
   'spice-util-glib.c',
   'usb-device-manager.c',
@@ -258,7 +260,7 @@
                                                     spice_client_glib_revision)
 summary_info += {'libspice-client-glib.so version': spice_client_glib_so_version}
 
-spice_client_glib_lib = library('spice-client-glib-2.0', spice_client_glib_sources,
+spice_client_glib_lib = library('cloonix-spice-client-glib-2.0', spice_client_glib_sources,
                                 version : spice_client_glib_so_version,
                                 install : true,
                                 include_directories : spice_gtk_include,
@@ -442,7 +444,7 @@
                                                      spice_client_gtk_revision)
   summary_info += {'libspice-client-gtk.so version': spice_client_gtk_so_version}
 
-  spice_client_gtk_lib = library('spice-client-gtk-3.0', spice_client_gtk_sources,
+  spice_client_gtk_lib = library('cloonix-spice-client-gtk-3.0', spice_client_gtk_sources,
                                  version : spice_client_gtk_so_version,
                                  install : true,
                                  link_args : [spice_gtk_version_script],
diff -Naur spice-gtk/src/spice-channel.c tainted_spice/src/spice-channel.c
--- spice-gtk/src/spice-channel.c	2024-04-12 23:36:08.000000000 +0200
+++ tainted_spice/src/spice-channel.c	2024-04-12 23:56:01.970815812 +0200
@@ -48,6 +48,11 @@
 
 G_STATIC_ASSERT(sizeof(SpiceChannelClass) == sizeof(GObjectClass) + 19 * sizeof(gpointer));
 
+/*CLOON*/
+#include "cloon.h"
+/*CLOON*/
+
+
 static void spice_channel_handle_msg(SpiceChannel *channel, SpiceMsgIn *msg);
 static void spice_channel_write_msg(SpiceChannel *channel, SpiceMsgOut *out);
 static void spice_channel_send_link(SpiceChannel *channel);
@@ -802,8 +807,9 @@
         }
     } else {
         GError *error = NULL;
-        ret = g_pollable_output_stream_write_nonblocking(G_POLLABLE_OUTPUT_STREAM(c->out),
-                                                         ptr, len, NULL, &error);
+
+        ret = cloonix_g_socket_send(c->sock, ptr, len, NULL, &error);
+
         if (ret < 0) {
             if (g_error_matches(error, G_IO_ERROR, G_IO_ERROR_WOULD_BLOCK)) {
                 *cond = G_IO_OUT;
@@ -1023,8 +1029,9 @@
         }
     } else {
         GError *error = NULL;
-        ret = g_pollable_input_stream_read_nonblocking(G_POLLABLE_INPUT_STREAM(c->in),
-                                                       data, len, NULL, &error);
+
+	ret = cloonix_g_socket_receive(c->sock, data, len, NULL, &error);
+
         if (ret < 0) {
             if (g_error_matches(error, G_IO_ERROR, G_IO_ERROR_WOULD_BLOCK)) {
                 *cond = G_IO_IN;
@@ -2268,6 +2275,7 @@
 
     g_return_val_if_fail(s != NULL, NULL);
 
+
     switch (type) {
     case SPICE_CHANNEL_MAIN:
         gtype = SPICE_TYPE_MAIN_CHANNEL;
@@ -2347,7 +2355,6 @@
 void spice_channel_destroy(SpiceChannel *channel)
 {
     g_return_if_fail(channel != NULL);
-
     CHANNEL_DEBUG(channel, "channel destroy");
     spice_channel_disconnect(channel, SPICE_CHANNEL_NONE);
     g_object_unref(channel);
@@ -2592,20 +2599,17 @@
             c->event = SPICE_CHANNEL_ERROR_CONNECT;
             goto cleanup;
         }
-
         if (!(c->sock = g_socket_new_from_fd(c->fd, NULL))) {
                 CHANNEL_DEBUG(channel, "Failed to open socket from fd %d", c->fd);
                 c->event = SPICE_CHANNEL_ERROR_CONNECT;
                 goto cleanup;
         }
-
         g_socket_set_blocking(c->sock, FALSE);
         g_socket_set_keepalive(c->sock, TRUE);
         c->conn = g_socket_connection_factory_create_connection(c->sock);
         goto connected;
     }
 
-
 reconnect:
     c->conn = spice_session_channel_open_host(c->session, channel, &c->tls, &c->error);
     if (c->conn == NULL) {
diff -Naur spice-gtk/src/spice-session.c tainted_spice/src/spice-session.c
--- spice-gtk/src/spice-session.c	2024-04-12 23:36:08.000000000 +0200
+++ tainted_spice/src/spice-session.c	2024-04-12 23:56:01.970815812 +0200
@@ -20,9 +20,8 @@
 #include <gio/gnetworking.h>
 #include <gio/gio.h>
 #include <glib.h>
-#ifdef G_OS_UNIX
 #include <gio/gunixsocketaddress.h>
-#endif
+#include "cloon.h"
 
 #include "spice-client.h"
 #include "spice-common.h"
@@ -43,11 +42,14 @@
 #define TCP_KEEPIDLE TCP_KEEPALIVE
 #endif
 
+
 #define IMAGES_CACHE_SIZE_DEFAULT (1024 * 1024 * 80)
 #define MIN_GLZ_WINDOW_SIZE_DEFAULT (1024 * 1024 * 12)
 #define MAX_GLZ_WINDOW_SIZE_DEFAULT MIN((LZ_MAX_WINDOW_SIZE * 4), 1024 * 1024 * 64)
 
 struct _SpiceSessionPrivate {
+    char              *cloonix_doors;
+    char              *cloonix_spice;
     char              *host;
     char              *unix_path;
     char              *port;
@@ -165,6 +167,8 @@
 /* Properties */
 enum {
     PROP_0,
+    PROP_CLOONIX_DOORS,
+    PROP_CLOONIX_SPICE,
     PROP_HOST,
     PROP_PORT,
     PROP_TLS_PORT,
@@ -357,6 +361,8 @@
     SpiceSessionPrivate *s = session->priv;
 
     /* release stuff */
+    g_free(s->cloonix_doors);
+    g_free(s->cloonix_spice);
     g_free(s->unix_path);
     g_free(s->host);
     g_free(s->port);
@@ -397,6 +403,10 @@
         return g_strdup_printf(URI_SCHEME_SPICE_UNIX "%s", s->unix_path);
     } else if (s->host != NULL) {
         const char *port, *scheme;
+
+//cloon suppress errors
+return NULL;
+
         g_return_val_if_fail(s->port != NULL || s->tls_port != NULL, NULL);
 
         if (s->tls_port && s->port) {
@@ -422,7 +432,9 @@
 static int spice_parse_uri(SpiceSession *session, const char *original_uri)
 {
     SpiceSessionPrivate *s = session->priv;
-    gchar *host = NULL, *port = NULL, *tls_port = NULL, *uri = NULL, *username = NULL, *password = NULL;
+    gchar *host = NULL, *port = NULL, *tls_port = NULL;
+    gchar *uri = NULL, *username = NULL, *password = NULL;
+    gchar *cloonix_doors = NULL, *cloonix_spice = NULL;
     gchar *path = NULL;
     gchar *authority = NULL;
     gchar *query = NULL;
@@ -544,7 +556,11 @@
         }
 
         target_key = NULL;
-        if (g_str_equal(key, "port")) {
+        if (g_str_equal(key, "cloonix-doors")) {
+            target_key = &cloonix_doors;
+        } else if (g_str_equal(key, "cloonix-spice")) {
+            target_key = &cloonix_spice;
+        } else if (g_str_equal(key, "port")) {
             target_key = &port;
         } else if (g_str_equal(key, "tls-port")) {
             target_key = &tls_port;
@@ -564,13 +580,15 @@
         }
     }
 
-    if (port == NULL && tls_port == NULL) {
-        g_warning("Missing port or tls-port in spice URI '%s'", original_uri);
-        goto fail;
-    }
+//    if (port == NULL && tls_port == NULL) {
+//        g_warning("Missing port or tls-port in spice URI '%s'", original_uri);
+//        goto fail;
+//    }
 
 end:
     /* parsed ok -> apply */
+    g_free(s->cloonix_doors);
+    g_free(s->cloonix_spice);
     g_free(s->unix_path);
     g_free(s->host);
     g_free(s->port);
@@ -588,6 +606,8 @@
     }
     s->username = username;
     s->password = password;
+    s->cloonix_doors = cloonix_doors;
+    s->cloonix_spice = cloonix_spice;
     return 0;
 
 fail:
@@ -597,6 +617,8 @@
     g_free(tls_port);
     g_free(username);
     g_free(password);
+    g_free(cloonix_doors);
+    g_free(cloonix_spice);
     return -1;
 }
 
@@ -609,6 +631,14 @@
     SpiceSessionPrivate *s = session->priv;
 
     switch (prop_id) {
+
+    case PROP_CLOONIX_DOORS:
+        g_value_set_string(value, s->cloonix_doors);
+        break;
+    case PROP_CLOONIX_SPICE:
+        g_value_set_string(value, s->cloonix_spice);
+        break;
+
     case PROP_HOST:
         g_value_set_string(value, s->host);
 	break;
@@ -733,6 +763,16 @@
     const char *str;
 
     switch (prop_id) {
+
+    case PROP_CLOONIX_DOORS:
+        g_free(s->cloonix_doors);
+        s->cloonix_doors = g_value_dup_string(value);
+        break;
+    case PROP_CLOONIX_SPICE:
+        g_free(s->cloonix_spice);
+        s->cloonix_spice = g_value_dup_string(value);
+        break;
+
     case PROP_HOST:
         g_free(s->host);
         s->host = g_value_dup_string(value);
@@ -878,6 +918,42 @@
     gobject_class->get_property = spice_session_get_property;
     gobject_class->set_property = spice_session_set_property;
 
+
+    /**
+     * SpiceSession:cloonix_doors:
+     *
+     * Add of the cloon server to connect to
+     *
+     **/
+    g_object_class_install_property
+        (gobject_class, PROP_CLOONIX_DOORS,
+         g_param_spec_string("cloonix-doors",
+                             "cloonix-doors",
+                             "cloonix-doors",
+                             NULL,
+                             G_PARAM_READWRITE |
+                             G_PARAM_CONSTRUCT |
+                             G_PARAM_STATIC_STRINGS));
+
+
+    /**
+     * SpiceSession:cloonix_spice:
+     *
+     * Unix socket access of the spice inside the cloon server
+     *
+     **/
+    g_object_class_install_property
+        (gobject_class, PROP_CLOONIX_SPICE,
+         g_param_spec_string("cloonix-spice",
+                             "cloonix-spice",
+                             "cloonix-spice",
+                             NULL,
+                             G_PARAM_READWRITE |
+                             G_PARAM_CONSTRUCT |
+                             G_PARAM_STATIC_STRINGS));
+
+
+
     /**
      * SpiceSession:host:
      *
@@ -1605,6 +1681,8 @@
     c = copy->priv;
     g_clear_object(&c->proxy);
 
+    g_warn_if_fail(c->cloonix_doors == NULL);
+    g_warn_if_fail(c->cloonix_spice == NULL);
     g_warn_if_fail(c->host == NULL);
     g_warn_if_fail(c->unix_path == NULL);
     g_warn_if_fail(c->tls_port == NULL);
@@ -1618,6 +1696,8 @@
     g_warn_if_fail(c->proxy == NULL);
 
     g_object_get(session,
+                 "cloonix-doors", &c->cloonix_doors,
+                 "cloonix-spice", &c->cloonix_spice,
                  "host", &c->host,
                  "unix-path", &c->unix_path,
                  "tls-port", &c->tls_port,
@@ -2100,14 +2180,37 @@
     GSocketClient *client = G_SOCKET_CLIENT(source_object);
     spice_open_host *open_host = data;
     GSocketConnection *connection = NULL;
+    GSocket *gsock;
+    int sock;
+    int is_connected;
+    char *cloonix_spice;
+    char *password;
+
+    if (open_host->connection != NULL)
+      {
+      syslog(LOG_ERR, "TWO CONNECTS FOR ONE REQUEST");
+      exit(-1);
+      }
 
     CHANNEL_DEBUG(open_host->channel, "connect ready");
-    connection = g_socket_client_connect_finish(client, result, &open_host->error);
+    connection = g_socket_client_connect_finish(client, result, 
+                                                &open_host->error);
     if (connection == NULL) {
         g_warn_if_fail(open_host->error != NULL);
         goto end;
     }
-
+    is_connected = g_socket_connection_is_connected(connection);
+    gsock = g_socket_connection_get_socket(connection);
+    sock = g_socket_get_fd(gsock);
+  if ((!is_connected) || (!gsock) || (sock <= 0))
+    {
+    syslog(LOG_ERR, "%s CONNECT PB %d %p %d", __FUNCTION__, 
+                    is_connected, gsock, sock);
+    exit(-1);
+    }
+    cloonix_spice =(char *)spice_session_get_cloonix_spice(open_host->session);
+    password = (char *) spice_session_get_password(open_host->session);
+    cloonix_preliminaries(password, gsock, sock, cloonix_spice);
     open_host->connection = connection;
 
 end:
@@ -2115,10 +2218,12 @@
 }
 
 /* main context */
-static void open_host_connectable_connect(spice_open_host *open_host, GSocketConnectable *connectable)
+static void open_host_connectable_connect(spice_open_host *open_host, 
+                                          GSocketConnectable *connectable)
 {
     CHANNEL_DEBUG(open_host->channel, "connecting %p...", open_host);
 
+    open_host->connection = NULL;
     g_socket_client_connect_async(open_host->client, connectable,
                                   open_host->cancellable,
                                   socket_client_connect_ready, open_host);
@@ -2164,6 +2269,12 @@
 {
     spice_open_host *open_host = data;
     SpiceSessionPrivate *s;
+    GInetAddress *ip_addr;
+    GSocketAddress *address = NULL;
+//    GSocketConnectable *address = NULL;
+    char doors_ip[100];
+    int doors_port;
+
 
     g_return_val_if_fail(open_host != NULL, FALSE);
     g_return_val_if_fail(open_host->connection == NULL, FALSE);
@@ -2183,28 +2294,19 @@
                                         spice_uri_get_hostname(open_host->proxy),
                                         open_host->cancellable,
                                         proxy_lookup_ready, open_host);
-    } else {
-        GSocketConnectable *address = NULL;
-
-        if (s->unix_path) {
-            SPICE_DEBUG("open unix path %s", s->unix_path);
-#ifdef G_OS_UNIX
-            address = G_SOCKET_CONNECTABLE(g_unix_socket_address_new(s->unix_path));
-#else
-            g_set_error_literal(&open_host->error, SPICE_CLIENT_ERROR, SPICE_CLIENT_ERROR_FAILED,
-                                "Unix path unsupported on this platform");
-#endif
-        } else {
-            SPICE_DEBUG("open host %s:%d", s->host, open_host->port);
-            address = g_network_address_parse(s->host, open_host->port, &open_host->error);
-        }
-
-        if (address == NULL || open_host->error != NULL) {
-            coroutine_yieldto(open_host->from, NULL);
-            return FALSE;
-        }
-
-        open_host_connectable_connect(open_host, address);
+    } 
+    else {
+        if (get_address_from_param(s->cloonix_doors, doors_ip, &doors_port))
+            {
+            ip_addr = g_inet_address_new_from_string(doors_ip);
+            address = g_inet_socket_address_new(ip_addr, doors_port);
+            }
+        else
+            {
+            syslog(LOG_ERR, "%s", s->cloonix_doors);
+            exit(-1);
+            }
+        open_host_connectable_connect(open_host, G_SOCKET_CONNECTABLE(address));
         g_object_unref(address);
     }
 
@@ -2221,15 +2323,18 @@
 
 /* coroutine context */
 G_GNUC_INTERNAL
-GSocketConnection* spice_session_channel_open_host(SpiceSession *session, SpiceChannel *channel,
-                                                   gboolean *use_tls, GError **error)
+GSocketConnection* spice_session_channel_open_host(SpiceSession *session, 
+                                                   SpiceChannel *channel,
+                                                   gboolean *use_tls, 
+                                                   GError **error)
 {
     g_return_val_if_fail(SPICE_IS_SESSION(session), NULL);
 
     SpiceSessionPrivate *s = session->priv;
     SpiceChannelPrivate *c = channel->priv;
     spice_open_host open_host = { 0, };
-    gchar *port, *endptr;
+ //   gchar *port, *endptr;
+
 
     // FIXME: make open_host() cancellable
     open_host.from = coroutine_self();
@@ -2241,31 +2346,6 @@
         spice_strv_contains(s->secure_channels, name))
         *use_tls = TRUE;
 
-    if (s->unix_path) {
-        if (*use_tls) {
-            CHANNEL_DEBUG(channel, "No TLS for Unix sockets");
-            return NULL;
-        }
-    } else {
-        port = *use_tls ? s->tls_port : s->port;
-        if (port == NULL) {
-            SPICE_DEBUG("Missing port value, not attempting %s connection.",
-                    *use_tls?"TLS":"unencrypted");
-            return NULL;
-        }
-
-        open_host.port = strtol(port, &endptr, 10);
-        if (*port == '\0' || *endptr != '\0' ||
-            open_host.port <= 0 || open_host.port > G_MAXUINT16) {
-            g_warning("Invalid port value %s", port);
-            return NULL;
-        }
-    }
-    if (*use_tls) {
-        CHANNEL_DEBUG(channel, "Using TLS, port %d", open_host.port);
-    } else {
-        CHANNEL_DEBUG(channel, "Using plain text, port %d", open_host.port);
-    }
 
     open_host.client = g_socket_client_new();
     g_socket_client_set_enable_proxy(open_host.client, s->proxy != NULL);
@@ -2524,6 +2604,27 @@
 }
 
 G_GNUC_INTERNAL
+const gchar* spice_session_get_cloonix_doors(SpiceSession *session)
+{
+    g_return_val_if_fail(SPICE_IS_SESSION(session), NULL);
+
+    SpiceSessionPrivate *s = session->priv;
+
+    return s->cloonix_doors;
+}
+
+G_GNUC_INTERNAL
+const gchar* spice_session_get_cloonix_spice(SpiceSession *session)
+{
+    g_return_val_if_fail(SPICE_IS_SESSION(session), NULL);
+
+    SpiceSessionPrivate *s = session->priv;
+
+    return s->cloonix_spice;
+}
+
+
+G_GNUC_INTERNAL
 const gchar* spice_session_get_host(SpiceSession *session)
 {
     g_return_val_if_fail(SPICE_IS_SESSION(session), NULL);
diff -Naur spice-gtk/src/spice-session-priv.h tainted_spice/src/spice-session-priv.h
--- spice-gtk/src/spice-session-priv.h	2024-04-12 23:36:08.000000000 +0200
+++ tainted_spice/src/spice-session-priv.h	2024-04-12 23:56:01.970815812 +0200
@@ -59,6 +59,8 @@
 void spice_session_get_pubkey(SpiceSession *session, guint8 **pubkey, guint *size);
 guint spice_session_get_verify(SpiceSession *session);
 const gchar* spice_session_get_username(SpiceSession *session);
+const gchar* spice_session_get_cloonix_doors(SpiceSession *session);
+const gchar* spice_session_get_cloonix_spice(SpiceSession *session);
 const gchar* spice_session_get_password(SpiceSession *session);
 const gchar* spice_session_get_host(SpiceSession *session);
 const gchar* spice_session_get_cert_subject(SpiceSession *session);
diff -Naur spice-gtk/src/spice-widget.c tainted_spice/src/spice-widget.c
--- spice-gtk/src/spice-widget.c	2024-04-12 23:36:08.000000000 +0200
+++ tainted_spice/src/spice-widget.c	2024-04-12 23:56:01.970815812 +0200
@@ -56,6 +56,10 @@
 #include "vncdisplaykeymap.h"
 #include "spice-grabsequence-priv.h"
 
+#include "cloon.h"
+
+int get_is_broadway(void);
+
 
 /**
  * SECTION:spice-widget
@@ -162,7 +166,7 @@
         g_value_set_boolean(value, d->keyboard_grab_enable);
         break;
     case PROP_MOUSE_GRAB:
-        g_value_set_boolean(value, d->mouse_grab_enable);
+          g_value_set_boolean(value, d->mouse_grab_enable);
         break;
     case PROP_RESIZE_GUEST:
         g_value_set_boolean(value, d->resize_guest_enable);
@@ -223,7 +227,15 @@
     reqwidth /= scale_factor;
     reqheight /= scale_factor;
 
-    gtk_widget_set_size_request(GTK_WIDGET(display), reqwidth, reqheight);
+    if (get_is_broadway())
+      {
+      gtk_widget_set_size_request(GTK_WIDGET(display), 470, 290);
+      }
+    else
+      {
+      gtk_widget_set_size_request(GTK_WIDGET(display), 680, 440);
+//      gtk_widget_set_size_request(GTK_WIDGET(display), reqwidth, reqheight);
+      }
     recalc_geometry(GTK_WIDGET(display));
     update_mouse_cursor(display);
 }
@@ -405,7 +417,10 @@
         update_keyboard_grab(display);
         break;
     case PROP_MOUSE_GRAB:
-        d->mouse_grab_enable = g_value_get_boolean(value);
+        if (get_is_broadway())
+          d->mouse_grab_enable = false;
+        else
+          d->mouse_grab_enable = g_value_get_boolean(value);
         update_mouse_grab(display);
         break;
     case PROP_RESIZE_GUEST:
@@ -519,13 +534,15 @@
                   event->implicit, event->keyboard);
     DISPLAY_DEBUG(self, "%s (SpiceDisplay::GdkWindow %p, event->grab_window: %p)",
                   __FUNCTION__, window, event->grab_window);
+//KERR("VIPTODO GRAB BROKEN");
     if (window == event->grab_window) {
+//KERR("VIPTODO GRAB BROKEN grab_window");
         /* ignore grab-broken event moving the grab to GtkEventBox::window
          * (from GtkEventBox::event_window) as we initially called
          * gdk_pointer_grab() on GtkEventBox::window, see
          * https://bugzilla.gnome.org/show_bug.cgi?id=769635
          */
-        return false;
+        return FALSE;
     }
 
     if (event->keyboard) {
@@ -538,7 +555,7 @@
        breaking someone else code. */
     try_mouse_ungrab(self);
 
-    return false;
+    return TRUE;
 }
 
 static void file_transfer_callback(GObject *source_object,
@@ -600,12 +617,17 @@
     gtk_drag_finish(drag_context, TRUE, FALSE, time);
 }
 
-static void grab_notify(SpiceDisplay *display, gboolean was_grabbed)
+static int grab_notify(SpiceDisplay *display, gboolean was_grabbed)
 {
     DISPLAY_DEBUG(display, "grab notify %d", was_grabbed);
+//KERR("VIPTODO GRAB NOTIFY");
 
     if (was_grabbed == FALSE)
+{
         release_keys(display);
+    try_mouse_ungrab(display);
+}
+return FALSE;
 }
 
 #ifdef HAVE_EGL
@@ -655,6 +677,7 @@
 #endif
 }
 
+
 static void spice_display_init(SpiceDisplay *display)
 {
     GtkWidget *widget = GTK_WIDGET(display);
@@ -700,6 +723,7 @@
     g_signal_connect(display, "grab-broken-event", G_CALLBACK(grab_broken), NULL);
     g_signal_connect(display, "grab-notify", G_CALLBACK(grab_notify), NULL);
 
+
     gtk_drag_dest_set(widget, GTK_DEST_DEFAULT_ALL, &targets, 1, GDK_ACTION_COPY);
     g_signal_connect(display, "drag-data-received",
                      G_CALLBACK(drag_data_received_callback), NULL);
@@ -1203,6 +1227,9 @@
     if (!d->keyboard_have_focus)
         return;
 
+    if (get_is_broadway())
+        return;
+
     if (!d->mouse_grab_enable)
         return;
     if (d->mouse_mode != SPICE_MOUSE_MODE_SERVER)
@@ -1355,12 +1382,15 @@
 {
     SpiceDisplayPrivate *d = display->priv;
 
-    if (d->mouse_grab_enable &&
-        !d->keyboard_grab_inhibit &&
-        !d->disable_inputs)
-        try_mouse_grab(display);
-    else
-        try_mouse_ungrab(display);
+    if (!get_is_broadway())
+      {
+      if (d->mouse_grab_enable &&
+          !d->keyboard_grab_inhibit &&
+          !d->disable_inputs)
+          try_mouse_grab(display);
+      else
+          try_mouse_ungrab(display);
+      }
 }
 
 static void recalc_geometry(GtkWidget *widget)
@@ -1511,7 +1541,9 @@
 
     if (d->mark == 0 || d->canvas.data == NULL ||
         d->area.width == 0 || d->area.height == 0)
+       {
         return false;
+       }
 
     spice_cairo_draw_event(display, cr);
     update_mouse_pointer(display);
@@ -1547,7 +1579,10 @@
     SpiceDisplayPrivate *d = display->priv;
 
     if (d->key_delayed_scancode == 0)
+{
+//KERR("VIPTODO key_press_delayed 1");
         return FALSE;
+}
 
     spice_inputs_channel_key_press(d->inputs, d->key_delayed_scancode);
     d->key_delayed_scancode = 0;
@@ -1557,6 +1592,7 @@
         d->key_delayed_id = 0;
     }
 
+//KERR("VIPTODO key_press_delayed 2");
     return FALSE;
 }
 
@@ -1576,6 +1612,7 @@
         spice_inputs_channel_key_release(inputs, 0x21d);
         spice_inputs_channel_key_release(inputs, 0x45);
     }
+//KERR("VIPTODO send_pause 1");
     return true;
 }
 
@@ -1660,7 +1697,10 @@
     int i;
 
     if (!d->grabseq->nkeysyms)
+      {
+//KERR("VIPTODO check_for_grab_key 1");
         return FALSE;
+      }
 
     if (type == check_type) {
         /* Record the new key */
@@ -1671,19 +1711,25 @@
         /* Return if any key is missing */
         for (i = 0 ; i < d->grabseq->nkeysyms ; i++)
             if (d->activeseq[i] == FALSE)
+               {
+//KERR("VIPTODO check_for_grab_key 2");
                 return FALSE;
+                }
 
         /* resets the whole grab sequence on success */
         memset(d->activeseq, 0, sizeof(gboolean) * d->grabseq->nkeysyms);
+//KERR("VIPTODO check_for_grab_key 3");
         return TRUE;
     } else if (type == reset_type) {
         /* reset key event type resets the whole grab sequence */
         memset(d->activeseq, 0, sizeof(gboolean) * d->grabseq->nkeysyms);
         d->seq_pressed = FALSE;
+//KERR("VIPTODO check_for_grab_key 4");
         return FALSE;
     } else
         g_warn_if_reached();
 
+//KERR("VIPTODO check_for_grab_key 5");
     return FALSE;
 }
 
@@ -1735,12 +1781,16 @@
 
     /* on windows, we ought to ignore the reserved key event? */
     if (!native_scancode && key->hardware_keycode == 0xff)
+      {
+//KERR("VIPTODO key_event 1");
         return false;
+      }
 
     if (!d->keyboard_grab_active) {
         if (key->hardware_keycode == VK_LWIN ||
             key->hardware_keycode == VK_RWIN ||
             key->hardware_keycode == VK_APPS)
+//KERR("VIPTODO key_event 2");
             return false;
     }
 
@@ -1772,9 +1822,13 @@
     }
 
     if (!d->inputs)
+       {
+//KERR("VIPTODO key_event 3");
         return true;
+       }
 
     if (key->keyval == GDK_KEY_Pause) {
+//KERR("VIPTODO key_event 4");
         return send_pause(display, key->type);
     }
     if (!scancode)
@@ -1888,6 +1942,7 @@
         break;
     }
 
+//KERR("VIPTODO key_event 5");
     return true;
 }
 
@@ -1905,9 +1960,11 @@
         g_free(keys);
     } else {
         g_warning("could not lookup keyval %u, please report a bug", keyval);
+//KERR("VIPTODO get_scancode_from_keyval 1");
         return 0;
     }
 
+//KERR("VIPTODO get_scancode_from_keyval 2");
     return vnc_display_keymap_gdk2xtkbd(d->keycode_map, d->keycode_maplen, keycode);
 }
 
@@ -1955,6 +2012,7 @@
     try_keyboard_grab(display);
     update_display(display);
 
+//KERR("VIPTODO enter_event 1");
     return true;
 }
 
@@ -1966,13 +2024,17 @@
     DISPLAY_DEBUG(display, "%s", __FUNCTION__);
 
     if (d->mouse_grab_active)
-        return true;
+        {
+//KERR("VIPTODO leave_event 1");
+        return false;
+        }
 
     d->mouse_have_pointer = false;
     spice_gtk_session_set_mouse_has_pointer(d->gtk_session, false);
     try_keyboard_ungrab(display);
 
-    return true;
+//KERR("VIPTODO leave_event 2");
+    return false;
 }
 
 static gboolean focus_in_event(GtkWidget *widget, GdkEventFocus *focus G_GNUC_UNUSED)
@@ -1987,8 +2049,10 @@
      * (this happens when doing an ungrab from the leave_event callback).
      */
     if (d->keyboard_have_focus)
+      {
+//KERR("VIPTODO focus_in_event 1");
         return true;
-
+      }
     release_keys(display);
 #ifdef G_OS_WIN32
     /* Reset the IME context of the focused window.
@@ -2009,6 +2073,7 @@
     if (gtk_widget_get_realized(widget))
         update_display(display);
 
+//KERR("VIPTODO focus_in_event 2");
     return true;
 }
 
@@ -2023,15 +2088,20 @@
      * Ignore focus out after a keyboard grab
      * (this happens when doing the grab from the enter_event callback).
      */
-#ifndef G_OS_WIN32
-    SpiceDisplayPrivate *d = display->priv;
-    if (d->keyboard_grab_active)
-        return true;
-#endif
+//
+//#ifndef G_OS_WIN32
+//    SpiceDisplayPrivate *d = display->priv;
+//    if (d->keyboard_grab_active)
+//      {
+//KERR("VIPTODO focus_out_event 1");
+//        return true;
+//      }
+//#endif
 
     release_keys(display);
     update_keyboard_focus(display, false);
 
+//KERR("VIPTODO focus_out_event 2");
     return true;
 }
 
@@ -2134,9 +2204,15 @@
     int x, y;
 
     if (!d->inputs)
+       {
+//KERR("VIPTODO motion_event 1");
         return true;
+       }
     if (d->disable_inputs)
+       {
+//KERR("VIPTODO motion_event 2");
         return true;
+       }
 
     d->seq_pressed = FALSE;
 
@@ -2195,9 +2271,15 @@
     DISPLAY_DEBUG(display, "%s", __FUNCTION__);
 
     if (!d->inputs)
+       {
+//KERR("VIPTODO scroll_event 1");
         return true;
+       }
     if (d->disable_inputs)
+       {
+//KERR("VIPTODO scroll_event 2");
         return true;
+       }
 
     switch (scroll->direction) {
     case GDK_SCROLL_UP:
@@ -2222,6 +2304,7 @@
         DISPLAY_DEBUG(display, "unsupported scroll direction");
     }
 
+//KERR("VIPTODO scroll_event 3");
     return true;
 }
 
@@ -2236,13 +2319,17 @@
                   button->button, button->state);
 
     if (d->disable_inputs)
+      {
+//KERR("VIPTODO button_event 1");
         return true;
+      }
 
     transform_input(display, button->x, button->y, &x, &y);
     if ((x < 0 || x >= d->area.width ||
          y < 0 || y >= d->area.height) &&
         d->mouse_mode == SPICE_MOUSE_MODE_CLIENT) {
         /* rule out clicks in outside region */
+//KERR("VIPTODO button_event 2");
         return true;
     }
 
@@ -2250,6 +2337,7 @@
     if (d->mouse_mode == SPICE_MOUSE_MODE_SERVER) {
         if (!d->mouse_grab_active) {
             try_mouse_grab(display);
+//KERR("VIPTODO button_event 3");
             return true;
         }
     } else {
@@ -2265,11 +2353,15 @@
            FIXME: should be multiple widget grab, but how?
            or should know the position of the other widgets?
         */
+//KERR("VIPTODO button_event 4");
         ungrab_pointer(display);
     }
 
     if (!d->inputs)
+      {
+//KERR("VIPTODO button_event 5");
         return true;
+      }
 
     switch (button->type) {
     case GDK_BUTTON_PRESS:
@@ -2279,6 +2371,7 @@
         /* Save the mouse button mask to couple it with Wayland movement */
         d->mouse_button_mask = button_mask_gdk_to_spice(button->state);
         d->mouse_button_mask |= button_gdk_to_spice_mask(button->button);
+//KERR("VIPTODO button_event 6");
         break;
     case GDK_BUTTON_RELEASE:
         spice_inputs_channel_button_release(d->inputs,
@@ -2287,10 +2380,13 @@
         /* Save the mouse button mask to couple it with Wayland movement */
         d->mouse_button_mask = button_mask_gdk_to_spice(button->state);
         d->mouse_button_mask ^= button_gdk_to_spice_mask(button->button);
+//KERR("VIPTODO button_event 7");
         break;
     default:
+//KERR("VIPTODO button_event 8");
         break;
     }
+//KERR("VIPTODO button_event 9");
     return true;
 }
 
@@ -2444,13 +2540,14 @@
                               G_PARAM_CONSTRUCT |
                               G_PARAM_STATIC_STRINGS));
 
+
     g_object_class_install_property
         (gobject_class, PROP_RESIZE_GUEST,
          g_param_spec_boolean("resize-guest",
                               "Resize guest",
                               "Try to adapt guest display on window resize. "
                               "Requires guest cooperation.",
-                              FALSE,
+                              TRUE,
                               G_PARAM_READWRITE |
                               G_PARAM_CONSTRUCT |
                               G_PARAM_STATIC_STRINGS));
diff -Naur spice-gtk/src/spice-widget-egl.c tainted_spice/src/spice-widget-egl.c
--- spice-gtk/src/spice-widget-egl.c	2024-04-12 23:36:08.000000000 +0200
+++ tainted_spice/src/spice-widget-egl.c	2024-04-12 23:56:01.974815837 +0200
@@ -226,7 +226,7 @@
 #endif
 
     d->egl.display = eglGetDisplay(dpy);
-    if (d->egl.display == EGL_NO_DISPLAY) {
+    if (d->egl.display == 0) {
         g_set_error_literal(err, SPICE_CLIENT_ERROR, SPICE_CLIENT_ERROR_FAILED,
                             "failed to get EGL display");
         return FALSE;
@@ -264,7 +264,7 @@
 
     d->egl.ctx = eglCreateContext(d->egl.display,
                                   d->egl.conf,
-                                  EGL_NO_CONTEXT,
+                                  0,
                                   ctx_att);
     if (!d->egl.ctx) {
         g_set_error_literal(err, SPICE_CLIENT_ERROR, SPICE_CLIENT_ERROR_FAILED,
@@ -272,7 +272,7 @@
         return FALSE;
     }
 
-    eglMakeCurrent(d->egl.display, EGL_NO_SURFACE, EGL_NO_SURFACE,
+    eglMakeCurrent(d->egl.display, 0, 0,
                    d->egl.ctx);
 
 #ifdef GDK_WINDOWING_WAYLAND
@@ -413,9 +413,9 @@
         /* egl.surface && egl.ctx are only created on x11, see
            spice_egl_init() */
 
-        if (d->egl.surface != EGL_NO_SURFACE) {
+        if (d->egl.surface != 0) {
             eglDestroySurface(d->egl.display, d->egl.surface);
-            d->egl.surface = EGL_NO_SURFACE;
+            d->egl.surface = 0;
         }
 
         if (d->egl.ctx) {
@@ -423,8 +423,8 @@
             d->egl.ctx = 0;
         }
 
-        eglMakeCurrent(d->egl.display, EGL_NO_SURFACE, EGL_NO_SURFACE,
-                       EGL_NO_CONTEXT);
+        eglMakeCurrent(d->egl.display, 0, 0,
+                       0);
 
         /* do not call eglterminate() since egl may be used by
          * somebody else code */
@@ -664,7 +664,7 @@
                   (int)(format >> 16) & 0xff, (int)format >> 24);
 
     d->egl.image = eglCreateImageKHR(d->egl.display,
-                                       EGL_NO_CONTEXT,
+                                       0,
                                        EGL_LINUX_DMA_BUF_EXT,
                                        (EGLClientBuffer)NULL,
                                        attrs);
diff -Naur spice-gtk/src/usb-acl-helper.c tainted_spice/src/usb-acl-helper.c
--- spice-gtk/src/usb-acl-helper.c	2024-04-12 23:36:08.000000000 +0200
+++ tainted_spice/src/usb-acl-helper.c	2024-04-12 23:56:01.974815837 +0200
@@ -24,6 +24,9 @@
 #include <stdio.h>
 #include <string.h>
 
+#include <glib-object.h>
+#include <gio/gio.h>
+#include "cloon.h"
 #include "usb-acl-helper.h"
 
 struct _SpiceUsbAclHelperPrivate {
@@ -181,9 +184,9 @@
     GIOStatus status;
     GPid helper_pid;
     gsize bytes_written;
-    const gchar *acl_helper = g_getenv("SPICE_USB_ACL_BINARY");
-    if (acl_helper == NULL)
-        acl_helper = ACL_HELPER_PATH"/spice-client-glib-usb-acl-helper";
+//    const gchar *acl_helper = g_getenv("SPICE_USB_ACL_BINARY");
+//    if (acl_helper == NULL)
+    const gchar *acl_helper = "/usr/libexec/cloonix/client/cloonix-spice-client-glib-usb-acl-helper";
     gchar *argv[] = { (char*)acl_helper, NULL };
     gint in, out;
     gchar buf[128];
@@ -217,6 +220,7 @@
     g_io_channel_set_close_on_unref(priv->out_ch, TRUE);
     status = g_io_channel_set_flags(priv->out_ch, G_IO_FLAG_NONBLOCK, &err);
     if (status != G_IO_STATUS_NORMAL) {
+        KERR("ERROR %s", acl_helper);
         g_task_return_error(task, err);
         goto done;
     }
diff -Naur spice-gtk/subprojects/spice-common/meson.build tainted_spice/subprojects/spice-common/meson.build
--- spice-gtk/subprojects/spice-common/meson.build	2024-04-12 23:36:16.000000000 +0200
+++ tainted_spice/subprojects/spice-common/meson.build	2024-04-12 23:56:01.974815837 +0200
@@ -169,10 +169,10 @@
 #
 subdir('python_modules')
 subdir('common')
-if get_option('tests')
-  subdir('tests')
-endif
-subdir('docs')
+# if get_option('tests')
+#   subdir('tests')
+# endif
+# subdir('docs')
 
 #
 # write config.h
diff -Naur spice-gtk/tools/spice-cmdline.c tainted_spice/tools/spice-cmdline.c
--- spice-gtk/tools/spice-cmdline.c	2024-04-12 23:36:08.000000000 +0200
+++ tainted_spice/tools/spice-cmdline.c	2024-04-12 23:56:01.974815837 +0200
@@ -27,9 +27,25 @@
 static char *tls_port;
 static char *password;
 static char *uri;
+static char *cloonix_doors;
+static char *cloonix_spice;
 
 static GOptionEntry spice_entries[] = {
-    {
+   {
+        .long_name        = "cloonix-doors",
+        .short_name       = 'd',
+        .arg              = G_OPTION_ARG_STRING,
+        .arg_data         = &cloonix_doors,
+        .description      = N_("Cloon door path"),
+        .arg_description  = N_("<cloonix_doors>"),
+    },{
+        .long_name        = "cloonix-spice",
+        .short_name       = 'c',
+        .arg              = G_OPTION_ARG_STRING,
+        .arg_data         = &cloonix_spice,
+        .description      = N_("Cloon spice server path"),
+        .arg_description  = N_("<cloonix_spice>"),
+    },{
         .long_name        = "uri",
         .arg              = G_OPTION_ARG_STRING,
         .arg_data         = &uri,
@@ -85,6 +101,10 @@
 {
     g_return_if_fail(SPICE_IS_SESSION(session));
 
+    if (cloonix_doors)
+        g_object_set(session, "cloonix-doors", cloonix_doors, NULL);
+    if (cloonix_spice)
+        g_object_set(session, "cloonix-spice", cloonix_spice, NULL);
     if (uri)
         g_object_set(session, "uri", uri, NULL);
     if (host)
diff -Naur spice-gtk/tools/spicy.c tainted_spice/tools/spicy.c
--- spice-gtk/tools/spicy.c	2024-04-12 23:36:08.000000000 +0200
+++ tainted_spice/tools/spicy.c	2024-04-12 23:56:01.974815837 +0200
@@ -35,6 +35,10 @@
 #include "spicy-connect.h"
 #include <gst/gst.h>
 
+#include "cloon.h"
+
+static int g_is_broadway;
+
 typedef struct spice_connection spice_connection;
 
 enum {
@@ -127,9 +131,15 @@
 /* globals */
 static GMainLoop     *mainloop = NULL;
 static int           connections = 0;
-static GKeyFile      *keyfile = NULL;
 static SpicePortChannel*stdin_port = NULL;
 
+
+int get_is_broadway(void)
+{
+  return g_is_broadway;
+}
+
+
 /* ------------------------------------------------------------------ */
 
 static int ask_user(GtkWidget *parent, char *title, char *message,
@@ -422,7 +432,6 @@
     name = gtk_action_get_name(GTK_ACTION(action));
     SPICE_DEBUG("%s: %s = %s", __FUNCTION__, name, state ? "yes" : "no");
 
-    g_key_file_set_boolean(keyfile, "general", name, state);
 
     if (is_gtk_session_property(name)) {
         object = win->conn->gtk_session;
@@ -452,7 +461,6 @@
     gboolean state = gtk_toggle_action_get_active(action);
 
     gtk_widget_set_visible(win->toolbar, state);
-    g_key_file_set_boolean(keyfile, "ui", "toolbar", state);
 }
 
 static void menu_cb_statusbar(GtkToggleAction *action, gpointer data)
@@ -461,7 +469,6 @@
     gboolean state = gtk_toggle_action_get_active(action);
 
     gtk_widget_set_visible(win->statusbar, state);
-    g_key_file_set_boolean(keyfile, "ui", "statusbar", state);
 }
 
 static void menu_cb_about(GtkAction *action, void *data)
@@ -540,6 +547,8 @@
 {
     SpiceWindow *win = data;
 
+//KERR("VIPTODO mouse_grab_cb grabbed %d", grabbed);
+
     win->mouse_grabbed = grabbed;
     update_status(win->conn);
 }
@@ -549,22 +558,10 @@
     SpiceWindow *win = data;
     GtkSettings *settings = gtk_widget_get_settings (widget);
 
-    if (grabbed) {
-        /* disable mnemonics & accels */
-        g_object_get(settings,
-                     "gtk-enable-accels", &win->enable_accels_save,
-                     "gtk-enable-mnemonics", &win->enable_mnemonics_save,
-                     NULL);
-        g_object_set(settings,
-                     "gtk-enable-accels", FALSE,
-                     "gtk-enable-mnemonics", FALSE,
-                     NULL);
-    } else {
-        g_object_set(settings,
-                     "gtk-enable-accels", win->enable_accels_save,
-                     "gtk-enable-mnemonics", win->enable_mnemonics_save,
-                     NULL);
-    }
+//KERR("VIPTODO keyboard_grab_cb              FALSE");
+    g_object_set(settings, "gtk-enable-accels", FALSE,
+                           "gtk-enable-mnemonics", FALSE,
+                           NULL);
 }
 
 static void menu_cb_resize_to(GtkAction *action G_GNUC_UNUSED,
@@ -627,66 +624,6 @@
     gtk_widget_destroy(dialog);
 }
 
-static void restore_configuration(SpiceWindow *win)
-{
-    gboolean state;
-    gchar *str;
-    gchar **keys = NULL;
-    gsize nkeys, i;
-    GError *error = NULL;
-    gpointer object;
-
-    keys = g_key_file_get_keys(keyfile, "general", &nkeys, &error);
-    if (error != NULL) {
-        if (error->code != G_KEY_FILE_ERROR_GROUP_NOT_FOUND)
-            g_warning("Failed to read configuration file keys: %s", error->message);
-        g_clear_error(&error);
-        return;
-    }
-
-    if (nkeys > 0)
-        g_return_if_fail(keys != NULL);
-
-    for (i = 0; i < nkeys; ++i) {
-        if (g_str_equal(keys[i], "grab-sequence"))
-            continue;
-        state = g_key_file_get_boolean(keyfile, "general", keys[i], &error);
-        if (error != NULL) {
-            g_clear_error(&error);
-            continue;
-        }
-
-        if (is_gtk_session_property(keys[i])) {
-            object = win->conn->gtk_session;
-        } else {
-            object = win->spice;
-        }
-        g_object_set(object, keys[i], state, NULL);
-    }
-
-    g_strfreev(keys);
-
-    str = g_key_file_get_string(keyfile, "general", "grab-sequence", &error);
-    if (error == NULL) {
-        SpiceGrabSequence *seq = spice_grab_sequence_new_from_string(str);
-        spice_display_set_grab_keys(SPICE_DISPLAY(win->spice), seq);
-        spice_grab_sequence_free(seq);
-        g_free(str);
-    }
-    g_clear_error(&error);
-
-
-    state = g_key_file_get_boolean(keyfile, "ui", "toolbar", &error);
-    if (error == NULL)
-        gtk_widget_set_visible(win->toolbar, state);
-    g_clear_error(&error);
-
-    state = g_key_file_get_boolean(keyfile, "ui", "statusbar", &error);
-    if (error == NULL)
-        gtk_widget_set_visible(win->statusbar, state);
-    g_clear_error(&error);
-}
-
 /* ------------------------------------------------------------------ */
 
 static const GtkActionEntry entries[] = {
@@ -724,12 +661,13 @@
         .stock_id    = "_Connect",
         .label       = "_Connect ...",
         .callback    = G_CALLBACK(menu_cb_connect),
+        .accelerator = "",
     },{
         .name        = "Close",
         .stock_id    = "window-close",
         .label       = "_Close",
         .callback    = G_CALLBACK(menu_cb_close),
-        .accelerator = "", /* none (disable default "<control>W") */
+        .accelerator = "",
     },{
 
         /* Edit menu */
@@ -737,13 +675,13 @@
         .stock_id    = "edit-copy",
         .label       = "_Copy to guest",
         .callback    = G_CALLBACK(menu_cb_copy),
-        .accelerator = "<shift>F5",
+        .accelerator = "",
     },{
         .name        = "PasteFromGuest",
         .stock_id    = "edit-paste",
         .label       = "_Paste from guest",
         .callback    = G_CALLBACK(menu_cb_paste),
-        .accelerator = "<shift>F6",
+        .accelerator = "",
     },{
 
         /* View menu */
@@ -751,7 +689,7 @@
         .stock_id    = "view-fullscreen",
         .label       = "_Fullscreen",
         .callback    = G_CALLBACK(menu_cb_fullscreen),
-        .accelerator = "<shift>F11",
+        .accelerator = "",
     },{
         .name        = "ResizeTo",
         .label       = "_Resize to",
@@ -762,12 +700,12 @@
 	.name        = "InsertSmartcard",
 	.label       = "_Insert Smartcard",
 	.callback    = G_CALLBACK(menu_cb_insert_smartcard),
-        .accelerator = "<shift>F8",
+        .accelerator = "",
     },{
 	.name        = "RemoveSmartcard",
 	.label       = "_Remove Smartcard",
 	.callback    = G_CALLBACK(menu_cb_remove_smartcard),
-        .accelerator = "<shift>F9",
+        .accelerator = "",
     },{
 #endif
 
@@ -775,14 +713,14 @@
         .name        = "SelectUsbDevices",
         .label       = "_Select USB Devices for redirection",
         .callback    = G_CALLBACK(menu_cb_select_usb_devices),
-        .accelerator = "<shift>F10",
+        .accelerator = "",
     },{
 #endif
 
         .name        = "MouseMode",
         .label       = "Toggle _mouse mode",
         .callback    = G_CALLBACK(menu_cb_mouse_mode),
-        .accelerator = "<shift>F7",
+        .accelerator = "",
 
     },{
         /* Help menu */
@@ -790,6 +728,7 @@
         .stock_id    = "help-about",
         .label       = "_About ...",
         .callback    = G_CALLBACK(menu_cb_about),
+        .accelerator = "",
     }
 };
 
@@ -1076,6 +1015,18 @@
     win->conn = conn;
     win->display_channel = channel;
 
+
+    if((getenv("GDK_BACKEND")) && (!strcmp(getenv("GDK_BACKEND"), "broadway")))
+      {
+//KERR("VIPTODO SPICY IS BROADWAY");
+      g_is_broadway = 1;
+      }
+    else
+      {
+//KERR("VIPTODO SPICY IS NOT BROADWAY");
+      g_is_broadway = 0;
+      }
+
     /* toplevel */
     win->toplevel = gtk_window_new(GTK_WINDOW_TOPLEVEL);
     if (spicy_title == NULL) {
@@ -1084,6 +1035,9 @@
         snprintf(title, sizeof(title), "%s", spicy_title);
     }
 
+    if (get_is_broadway())
+      gtk_window_set_type_hint(GTK_WINDOW(win->toplevel), GDK_WINDOW_TYPE_HINT_MENU);
+
     gtk_window_set_title(GTK_WINDOW(win->toplevel), title);
     g_signal_connect(G_OBJECT(win->toplevel), "window-state-event",
                      G_CALLBACK(window_state_cb), win);
@@ -1150,12 +1104,10 @@
     spice_display_set_grab_keys(SPICE_DISPLAY(win->spice), seq);
     spice_grab_sequence_free(seq);
 
-    g_signal_connect(G_OBJECT(win->spice), "mouse-grab",
-                     G_CALLBACK(mouse_grab_cb), win);
-    g_signal_connect(G_OBJECT(win->spice), "keyboard-grab",
-                     G_CALLBACK(keyboard_grab_cb), win);
-    g_signal_connect(G_OBJECT(win->spice), "grab-keys-pressed",
-                     G_CALLBACK(grab_keys_pressed_cb), win);
+    if (!get_is_broadway())
+      g_signal_connect(G_OBJECT(win->spice), "mouse-grab", G_CALLBACK(mouse_grab_cb), win);
+    g_signal_connect(G_OBJECT(win->spice), "keyboard-grab", G_CALLBACK(keyboard_grab_cb), win);
+    g_signal_connect(G_OBJECT(win->spice), "grab-keys-pressed", G_CALLBACK(grab_keys_pressed_cb), win);
 
     /* status line */
     win->statusbar = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 1);
@@ -1181,8 +1133,9 @@
     vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 1);
     gtk_container_set_border_width(GTK_CONTAINER(vbox), 0);
     gtk_container_add(GTK_CONTAINER(win->toplevel), vbox);
-    gtk_box_pack_start(GTK_BOX(vbox), win->menubar, FALSE, FALSE, 0);
-    gtk_box_pack_start(GTK_BOX(vbox), win->toolbar, FALSE, FALSE, 0);
+    if (!get_is_broadway())
+      gtk_box_pack_start(GTK_BOX(vbox), win->menubar, FALSE, FALSE, 0);
+//    gtk_box_pack_start(GTK_BOX(vbox), win->toolbar, FALSE, FALSE, 0);
     gtk_box_pack_start(GTK_BOX(vbox), win->spice, TRUE, TRUE, 0);
     gtk_box_pack_end(GTK_BOX(vbox), win->statusbar, FALSE, TRUE, 0);
 
@@ -1191,7 +1144,6 @@
         gtk_window_fullscreen(GTK_WINDOW(win->toplevel));
 
     gtk_widget_show_all(vbox);
-    restore_configuration(win);
 
     /* init toggle actions */
     for (i = 0; i < G_N_ELEMENTS(spice_display_properties); i++) {
@@ -1272,29 +1224,29 @@
 
 static void recent_add(SpiceSession *session)
 {
-    GtkRecentManager *recent;
-    GtkRecentData meta = {
-        .mime_type    = (char*)"application/x-spice",
-        .app_name     = (char*)"spicy",
-        .app_exec     = (char*)"spicy --uri=%u",
-    };
-    char *uri;
-
-    g_object_get(session, "uri", &uri, NULL);
-    SPICE_DEBUG("%s: %s", __FUNCTION__, uri);
-
-    recent = gtk_recent_manager_get_default();
-    if (g_str_has_prefix(uri, "spice://"))
-        meta.display_name = uri + 8;
-    else if (g_str_has_prefix(uri, "spice+unix://"))
-        meta.display_name = uri + 13;
-    else
-        g_return_if_reached();
-
-    if (!gtk_recent_manager_add_full(recent, uri, &meta))
-        g_warning("Recent item couldn't be added successfully");
-
-    g_free(uri);
+//cloon suppress error
+//    GtkRecentManager *recent;
+//    GtkRecentData meta = {
+//        .mime_type    = (char*)"application/x-spice",
+//        .app_name     = (char*)"spicy",
+//        .app_exec     = (char*)"spicy --uri=%u",
+//    };
+//    char *uri;
+//
+//    g_object_get(session, "uri", &uri, NULL);
+//    SPICE_DEBUG("%s: %s", __FUNCTION__, uri);
+//
+//    recent = gtk_recent_manager_get_default();
+//
+//    if (g_str_has_prefix(uri, "spice://"))
+//        meta.display_name = uri + 8;
+//    else if (g_str_has_prefix(uri, "spice+unix://"))
+//        meta.display_name = uri + 13;
+//    else
+//        g_return_if_reached();
+//    if (!gtk_recent_manager_add_full(recent, uri, &meta))
+//        g_warning("Recent item couldn't be added successfully");
+//    g_free(uri);
 }
 
 static void main_channel_event(SpiceChannel *channel, SpiceChannelEvent event,
@@ -1307,7 +1259,7 @@
 
     switch (event) {
     case SPICE_CHANNEL_OPENED:
-        g_message("main channel: opened");
+//        g_message("main channel: opened");
         recent_add(conn->session);
         break;
     case SPICE_CHANNEL_SWITCHING:
@@ -1315,7 +1267,7 @@
         break;
     case SPICE_CHANNEL_CLOSED:
         /* this event is only sent if the channel was succesfully opened before */
-        g_message("main channel: closed");
+//        g_message("main channel: closed");
         connection_disconnect(conn);
         break;
     case SPICE_CHANNEL_ERROR_IO:
@@ -2011,23 +1963,6 @@
     GError *error = NULL;
     GOptionContext *context;
     spice_connection *conn;
-    gchar *conf_file, *conf;
-    char *host = NULL, *port = NULL, *tls_port = NULL, *unix_path = NULL;
-
-    keyfile = g_key_file_new();
-
-    int mode = S_IRWXU;
-    conf_file = g_build_filename(g_get_user_config_dir(), "spicy", NULL);
-    if (g_mkdir_with_parents(conf_file, mode) == -1)
-        SPICE_DEBUG("failed to create config directory");
-    g_free(conf_file);
-
-    conf_file = g_build_filename(g_get_user_config_dir(), "spicy", "settings", NULL);
-    if (!g_key_file_load_from_file(keyfile, conf_file,
-                                   G_KEY_FILE_KEEP_COMMENTS|G_KEY_FILE_KEEP_TRANSLATIONS, &error)) {
-        SPICE_DEBUG("Couldn't load configuration: %s", error->message);
-        g_clear_error(&error);
-    }
 
     /* parse opts */
     gtk_init(&argc, &argv);
@@ -2056,40 +1991,12 @@
     spice_set_session_option(conn->session);
     spice_cmdline_session_setup(conn->session);
 
-    g_object_get(conn->session,
-                 "unix-path", &unix_path,
-                 "host", &host,
-                 "port", &port,
-                 "tls-port", &tls_port,
-                 NULL);
-    /* If user doesn't provide hostname and port, show the dialog window
-       instead of connecting to server automatically */
-    if ((host == NULL || (port == NULL && tls_port == NULL)) && unix_path == NULL) {
-        if (!spicy_connect_dialog(conn->session)) {
-            exit(0);
-        }
-    }
-    g_free(host);
-    g_free(port);
-    g_free(tls_port);
-    g_free(unix_path);
 
     connection_connect(conn);
     if (connections > 0)
         g_main_loop_run(mainloop);
     g_main_loop_unref(mainloop);
 
-    if ((conf = g_key_file_to_data(keyfile, NULL, &error)) == NULL ||
-        !g_file_set_contents(conf_file, conf, -1, &error)) {
-        SPICE_DEBUG("Couldn't save configuration: %s", error->message);
-        g_error_free(error);
-        error = NULL;
-    }
-
-    g_free(conf_file);
-    g_free(conf);
-    g_key_file_free(keyfile);
-
     g_free(spicy_title);
 
     setup_terminal(true);
