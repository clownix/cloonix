diff -Naur spice-gtk/src/cloon.c tainted_spice/src/cloon.c
--- spice-gtk/src/cloon.c	1970-01-01 01:00:00.000000000 +0100
+++ tainted_spice/src/cloon.c	2022-07-14 09:22:54.461154914 +0200
@@ -0,0 +1,609 @@
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <syslog.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <sys/stat.h>
+
+#include <errno.h>
+
+#include <glib-object.h>
+#include <gio/gio.h>
+
+#include "cloon.h"
+#include "hmac_cipher.h"
+
+
+typedef struct t_rx_pktbuf
+{
+  char buf[MAX_DOORWAYS_BUF_LEN];
+  int  offset;
+  int  idx_hmac;
+  int  dido_llid;
+  int  size_req;
+  int  paylen;
+  int  paylen_given;
+  int  type;
+  int  val;
+  int  nb_pkt_rx;
+  char *payload;
+} t_rx_pktbuf;
+
+
+
+typedef struct t_sock_ctx
+{
+  GSocket *gsock;
+  int sock;
+  int nb_tx_pkt;
+  t_rx_pktbuf rx_pktbuf;
+} t_sock_ctx;
+
+static t_sock_ctx *g_sock_ctx[MAX_FD_NUMBER_CTX];
+
+
+/*****************************************************************************/
+static int test_file_is_socket(char *path)
+{
+  int result = -1;
+  struct stat stat_file;
+  if (!stat(path, &stat_file))
+    {
+    if (S_ISSOCK(stat_file.st_mode))
+      result = 0;
+    }
+  return result;
+}
+/*---------------------------------------------------------------------------*/
+
+uint64_t cloonix_get_msec(void)
+{
+  return 0;
+}
+/****************************************************************************/
+static int tst_port(char *str_port, int *port)
+{
+  int result = 0;
+  unsigned long val;
+  char *endptr;
+  val = strtoul(str_port, &endptr, 10);
+  if ((endptr == NULL)||(endptr[0] != 0))
+    result = -1;
+  else
+    {
+    if ((val < 1) || (val > 65535))
+      result = -1;
+    *port = (int) val;
+    }
+  return result;
+}
+/*--------------------------------------------------------------------------*/
+
+/*****************************************************************************/
+int get_address_from_param(char *param, char *ip, int *port)
+{
+  char pm[100];
+  int result = 0;
+  char *ptr_ip, *ptr_port;
+  if (strlen(param) >= 100)
+    KOUT("param LENGTH Problem");
+  else
+    {
+    memset(pm, 0, 100);
+    memset(ip, 0, 100);
+    strncpy(pm, param, 100-1);
+    ptr_ip = pm;
+    ptr_port = strchr(pm, ':');
+    if (ptr_port)
+      {
+      result = 1;
+      *ptr_port = 0;
+      ptr_port++;
+      strncpy(ip, ptr_ip, 100);
+      if (tst_port(ptr_port, port))
+        KOUT("PORT param Problem %s", param);
+      }
+    else
+      {
+      if (test_file_is_socket(param))
+        KOUT("Not unix: %s", param);
+      }
+    }
+  return result;
+}
+/*---------------------------------------------------------------------------*/
+
+/****************************************************************************/
+static void alloc_sock_ctx(GSocket *gsock, int sock)
+{
+  int fd_sock = g_socket_get_fd(gsock);
+  if (sock != fd_sock)
+    KOUT("%d %d", sock, fd_sock);
+  if (g_sock_ctx[sock])
+    KOUT(" ");
+  g_sock_ctx[sock] = (t_sock_ctx *) malloc(sizeof(t_sock_ctx));
+  memset(g_sock_ctx[sock], 0, sizeof(t_sock_ctx));
+  g_sock_ctx[sock]->gsock = gsock;
+  g_sock_ctx[sock]->sock = sock;
+  g_sock_ctx[sock]->nb_tx_pkt = 1;
+  g_sock_ctx[sock]->rx_pktbuf.nb_pkt_rx = 1;
+}
+/*--------------------------------------------------------------------------*/
+
+/****************************************************************************/
+static t_sock_ctx *get_sock_ctx(int sock)
+{
+  return g_sock_ctx[sock];
+}
+/*--------------------------------------------------------------------------*/
+
+
+/****************************************************************************/
+static void set_hmac_password(int i, char *tx, int len, char *payload)
+{
+  int j, idx = i;
+  char *md = compute_msg_digest(len, payload);
+  for (j=0; j<MSG_DIGEST_LEN; j++)
+    tx[idx++] = md[j];
+}
+/*--------------------------------------------------------------------------*/
+
+/****************************************************************************/
+static int check_hmac_password(int i, char *rx, int len, char *payload)
+{
+  int j, k, idx, result = 0;
+  char *md = compute_msg_digest(len, payload);
+  idx = i;
+  for (j=0; j<MSG_DIGEST_LEN; j++)
+    {
+    k = idx++;
+    if (rx[k] != md[j])
+      {
+      result = -1;
+      break;
+      }
+    }
+  return result;
+}
+/*--------------------------------------------------------------------------*/
+
+
+/****************************************************************************/
+static void sock_header_set_info(char *tx,
+                                 int llid, int len, int type, int val,
+                                 int nb_pkt, char **ntx)
+{
+  int idx_hmac, i = 0;
+
+  tx[i++] = 0xCA & 0xFF;
+  tx[i++] = 0xFE & 0xFF;
+
+  tx[i++] = ((llid & 0xFF00) >> 8) & 0xFF;
+  tx[i++] = llid & 0xFF;
+  tx[i++] = ((len & 0xFF000000) >> 24) & 0xFF;
+  tx[i++] = ((len & 0xFF0000) >> 16) & 0xFF;
+  tx[i++] = ((len & 0xFF00) >> 8) & 0xFF;
+  tx[i++] = len & 0xFF;
+  tx[i++] = ((type & 0xFF00) >> 8) & 0xFF;
+  tx[i++] = type & 0xFF;
+  tx[i++] = ((val & 0xFF00) >> 8) & 0xFF;
+  tx[i++] = val & 0xFF;
+  tx[i++] = ((nb_pkt & 0xFF00) >> 8) & 0xFF;
+  tx[i++] = nb_pkt & 0xFF;
+  idx_hmac = i;
+  i += MSG_DIGEST_LEN;
+  tx[i++] = 0xDE & 0xFF;
+  tx[i++] = 0xCA & 0xFF;
+
+  *ntx = &(tx[i++]);
+  set_hmac_password(idx_hmac, tx, len, *ntx);
+}
+/*--------------------------------------------------------------------------*/
+
+
+/****************************************************************************/
+static int sock_header_get_info(char *rx,
+                                 int *llid, int *len, int *type, int *val,
+                                 int *nb_pkt, char **nrx)
+{
+  int idx_hmac, i = 0, result=0;
+  if ((rx[i++] & 0xFF) != 0xCA)
+    {
+    for (i=0; i<16; i++)
+      printf(" %02X", (unsigned int)(rx[i] & 0xFF));
+    KERR("%02X \n", (unsigned int)(rx[0] & 0xFF));
+    result = -1;
+    }
+  else if ((rx[i++] & 0xFF) != 0xFE)
+    {
+    KERR("%02X \n", (unsigned int) (rx[1]));
+    result = -1;
+    }
+  else
+    {
+    *llid = ((rx[i] & 0xFF) << 8) + (rx[i+1] & 0xFF);
+    i += 2; 
+    *len  = ((rx[i] & 0xFF) << 24) + ((rx[i+1] & 0xFF) << 16);
+    i += 2;
+    *len  += ((rx[i] & 0xFF) << 8) + (rx[i+1] & 0xFF);
+    i += 2; 
+    *type = ((rx[i] & 0xFF) << 8) + (rx[i+1] & 0xFF);
+    i += 2; 
+    *val  = ((rx[i] & 0xFF) << 8) + (rx[i+1] & 0xFF);
+    i += 2;  
+    *nb_pkt  = ((rx[i] & 0xFF) << 8) + (rx[i+1] & 0xFF);
+    i += 2;
+    idx_hmac = i;
+    i += MSG_DIGEST_LEN; 
+    if ((rx[i++] & 0xFF) != 0xDE)
+      {
+      KERR("%02X \n", (unsigned int) (rx[i-1]));
+      result = -1;
+      }
+    else if ((rx[i++] & 0xFF) != 0xCA)
+      {
+      KERR("%02X \n", (unsigned int) (rx[i-1]));
+      result = -1;
+      }
+    else
+      {
+      result = idx_hmac;
+      *nrx  = &(rx[i++]);
+      }
+    }
+  return result;
+}
+/*--------------------------------------------------------------------------*/
+
+/****************************************************************************/
+static int check_extract_rx(char *rx, int expect_val, int expect_pkt, 
+                            int *len, char **payload) 
+{
+  int idx_hmac, type, llid, val, pkt, result = -1;
+  idx_hmac = sock_header_get_info(rx, &llid, len, &type, &val, &pkt, payload);
+  if (idx_hmac != -1)
+    {
+    if (type != doors_type_spice)
+      KERR("%d", type);
+    else if (val != expect_val)
+      KERR("%d %d", val, expect_val);
+    else if (pkt != expect_pkt)
+      {
+      result = 0;
+      KERR("%d %d", pkt, expect_pkt);
+      }
+    else if (idx_hmac != 14)
+      KOUT("%d", idx_hmac); 
+    else
+      result = 0;
+    }
+  return result;
+}
+/*--------------------------------------------------------------------------*/
+
+/****************************************************************************/
+static int rx_first_msg(int sock, int *dlen, char **drx)
+{
+  char rx[DOORWAYS_HEADER_SIZE + 3];
+  int len, result = -1;
+  fd_set infd;
+  FD_ZERO(&infd);
+  FD_SET(sock, &infd);
+  result = select(sock + 1, &infd, NULL, NULL, NULL);
+  if ( result < 0 )
+    KOUT(" ");
+  else if (FD_ISSET(sock, &infd))
+    {
+    len = read(sock, rx, DOORWAYS_HEADER_SIZE + 3);
+    if (len != DOORWAYS_HEADER_SIZE + 3)
+      KERR("%d %d", len, DOORWAYS_HEADER_SIZE + 3);
+    else
+      {
+      result = check_extract_rx(rx, doors_val_link_ok, 1, dlen, drx);
+      if (result)
+        KOUT(" ");
+      result = check_hmac_password(14, rx, *dlen, *drx);
+      if (result)
+        KOUT("BAD PASSWORD");
+      }
+    }
+  else
+    KOUT(" ");
+  return result;
+}
+/*--------------------------------------------------------------------------*/
+
+/****************************************************************************/
+static int tx_header(int val, int len, char *buf, int nb_pkt_tx)
+{
+  char *payload;
+  int tot_len = len + DOORWAYS_HEADER_SIZE;
+  sock_header_set_info(buf, 0, len, 
+                       doors_type_spice, val,
+                       nb_pkt_tx, &payload);
+  if (payload != buf + DOORWAYS_HEADER_SIZE)
+    KOUT("%p %p", payload, buf);
+  return tot_len;
+}
+/*---------------------------------------------------------------------------*/
+
+/****************************************************************************/
+static int rx_pktbuf_fill(t_sock_ctx *ctx, t_rx_pktbuf *rx_pktbuf, 
+                          GError **error)
+{
+  int headsize = DOORWAYS_HEADER_SIZE;
+  int result, len_desired, len_avail;
+  if (rx_pktbuf->offset < headsize)
+    {
+    if (rx_pktbuf->paylen != 0)
+      KOUT(" ");
+    if (rx_pktbuf->payload)
+      KOUT(" ");
+    len_desired = headsize - rx_pktbuf->offset;
+    result = 1;
+    }
+  else
+    {
+    if (rx_pktbuf->paylen <= 0)
+      KOUT(" ");
+    if (!rx_pktbuf->payload)
+      KOUT(" ");
+    len_desired = headsize + rx_pktbuf->paylen - rx_pktbuf->offset;
+    if (len_desired > rx_pktbuf->size_req)
+      len_desired = rx_pktbuf->size_req;
+    result = 3;
+    }
+  if (len_desired + rx_pktbuf->offset > MAX_DOORWAYS_BUF_LEN)
+    KOUT("%d %d", len_desired, rx_pktbuf->offset);
+  len_avail = g_socket_receive(ctx->gsock, 
+                               rx_pktbuf->buf + rx_pktbuf->offset, 
+                               len_desired, NULL, error);
+  if (len_avail > 0)
+    {
+    rx_pktbuf->offset += len_avail;
+    if ((result == 1) && (len_desired != len_avail))
+      result = 2; 
+    if ((result == 3) && (len_avail > 0))
+      result = 5; 
+    }
+  else
+    result = -1;
+  return result;
+}
+/*--------------------------------------------------------------------------*/
+
+/****************************************************************************/
+static int rx_pktbuf_get_paylen(t_rx_pktbuf *rx_pktbuf)
+{
+  int nb_pkt, result = 0;
+  rx_pktbuf->idx_hmac = sock_header_get_info(rx_pktbuf->buf,
+                                             &(rx_pktbuf->dido_llid),
+                                             &(rx_pktbuf->paylen),
+                                             &(rx_pktbuf->type),
+                                             &(rx_pktbuf->val),
+                                             &(nb_pkt),
+                                             &(rx_pktbuf->payload));
+  if (rx_pktbuf->idx_hmac == -1)
+    {
+    KOUT(" ");
+    result = -1;
+    rx_pktbuf->offset = 0;
+    rx_pktbuf->paylen = 0;
+    rx_pktbuf->payload = NULL;
+    rx_pktbuf->dido_llid = 0;
+    rx_pktbuf->type = 0;
+    rx_pktbuf->val = 0;
+    }
+  else
+    {
+    if ((nb_pkt-1) != rx_pktbuf->nb_pkt_rx)
+      {
+      KERR("%d %d", nb_pkt, rx_pktbuf->nb_pkt_rx);
+      result = -1;
+      }
+    if (nb_pkt == 0xFFFF)
+      rx_pktbuf->nb_pkt_rx = 0;
+    else
+      rx_pktbuf->nb_pkt_rx = nb_pkt;
+    }
+  return result;
+}
+/*--------------------------------------------------------------------------*/
+
+/****************************************************************************/
+static int rx_doorways(t_sock_ctx *ctx, t_rx_pktbuf *rx_pktbuf, GError **error)
+{
+  int res;
+  int headsize = DOORWAYS_HEADER_SIZE;
+
+  if ((rx_pktbuf->paylen > 0) && 
+      (rx_pktbuf->offset == rx_pktbuf->paylen + headsize) &&
+      (rx_pktbuf->paylen_given < rx_pktbuf->paylen)) 
+    {
+    res = 5;
+    }
+  else
+    {
+    res = rx_pktbuf_fill(ctx, rx_pktbuf, error);
+    if (res == 1)
+      {
+      rx_pktbuf_get_paylen(rx_pktbuf);
+      res = rx_pktbuf_fill(ctx, rx_pktbuf, error);
+      }
+    }
+
+  if (res == 5)
+    {
+    if (!rx_pktbuf->payload)
+      KOUT(" ");
+    if (rx_pktbuf->paylen <= 0)
+      KOUT(" ");
+    if (rx_pktbuf->idx_hmac != 14)
+      KOUT("%d", rx_pktbuf->idx_hmac);
+    if (rx_pktbuf->type != doors_type_spice)
+      KOUT("%d %d", rx_pktbuf->type, doors_type_spice);
+    if (rx_pktbuf->val != doors_val_none)
+      KOUT("%d %d", rx_pktbuf->val, doors_val_none);
+    if (rx_pktbuf->offset == rx_pktbuf->paylen + headsize)
+      {
+      if (check_hmac_password(rx_pktbuf->idx_hmac, rx_pktbuf->buf,
+                            rx_pktbuf->paylen, rx_pktbuf->payload))
+        KOUT("BAD PASSWORD: %d %d %d", rx_pktbuf->paylen, 
+                                       rx_pktbuf->offset, 
+                                       rx_pktbuf->paylen_given);
+      }
+    }
+  return res;
+}
+/*--------------------------------------------------------------------------*/
+
+/****************************************************************************/
+static int tx_doorways(t_sock_ctx *ctx, int len, char *buf, GError **error)
+{
+  int ret, tot_len, result = 0;
+  char *msg_buf;
+  int max = MAX_DOORWAYS_BUF_LEN - DOORWAYS_HEADER_SIZE;
+  if ((len<0) || (len >= max))
+    KOUT("%d %d", len, max);
+  if (len > 0)
+    {
+    if (ctx->nb_tx_pkt == 0xFFFF)
+      ctx->nb_tx_pkt = 1;
+    else
+      ctx->nb_tx_pkt += 1;
+    msg_buf = (char *) malloc(len + DOORWAYS_HEADER_SIZE);
+    memcpy(msg_buf + DOORWAYS_HEADER_SIZE, buf, len);
+    tot_len = tx_header(doors_val_none, len, msg_buf, ctx->nb_tx_pkt);
+    ret = g_socket_send(ctx->gsock, msg_buf, tot_len, NULL, error);
+    if (ret <= 0)
+      result = ret;
+    else if (ret != tot_len)
+      KOUT("%d %d", ret, tot_len);
+    else 
+      result = len; 
+    free(msg_buf);
+    }
+  return result;
+}
+/*---------------------------------------------------------------------------*/
+
+/****************************************************************************/
+void cloonix_preliminaries(char *password, GSocket *gsock, int sock, char *spice_sock) 
+{
+  char buf[300+DOORWAYS_HEADER_SIZE];
+  int headsize = DOORWAYS_HEADER_SIZE;
+  int len = strlen(spice_sock) + 1;
+  int tot_len, tx_len, dlen;
+  char *drx;
+  if (!password)
+    KOUT(" ");
+  if (strlen(password) < 2)
+    KOUT("%d %s", (int) strlen(password), password);
+  if (strlen(password) >= MSG_DIGEST_LEN)
+    KOUT("%d %s", (int) strlen(password), password);
+  cipher_myinit(password);
+  if (sock >= MAX_FD_NUMBER_CTX)
+    KOUT("%d %d", sock, MAX_FD_NUMBER_CTX);
+  memset(buf, 0, 300);
+  strncpy(buf+headsize, spice_sock, 300-1); 
+  tot_len = tx_header(doors_val_init_link, len, buf, 1);
+  tx_len = write(sock, buf, tot_len); 
+  if (tx_len != tot_len)
+    KERR("ERR tx : %d %d", tx_len, tot_len);
+  if (!rx_first_msg(sock, &dlen, &drx))
+    {
+    alloc_sock_ctx(gsock, sock);
+    }
+  else
+    KERR("ERROR %s", drx);
+}
+
+
+
+/****************************************************************************/
+gssize cloonix_g_socket_send (GSocket *socket, const gchar *buffer, 
+                              gsize size, GCancellable *cancellable, 
+                              GError **error)
+{
+  gssize ret;
+  int fd_sock;
+  t_sock_ctx *ctx;
+  fd_sock = g_socket_get_fd(socket);
+  ctx = get_sock_ctx(fd_sock);
+  if (!ctx)
+    KOUT(" ");
+  ret = tx_doorways(ctx, (int) size, (char *) buffer, error);
+  return ret;
+}
+/*--------------------------------------------------------------------------*/
+
+
+/****************************************************************************/
+gssize cloonix_g_socket_receive(GSocket *socket, gchar *buffer, gsize size,
+                                GCancellable *cancellable, GError **error)
+{
+  int headsize = DOORWAYS_HEADER_SIZE;
+  int fd_sock, result, len_to_give, left_to_give;
+  t_sock_ctx *ctx;
+  t_rx_pktbuf *rx_pktbuf;
+  fd_sock = g_socket_get_fd(socket);
+  ctx = get_sock_ctx(fd_sock);
+  if (!ctx)
+    KOUT(" ");
+  if (socket != ctx->gsock)
+    KOUT(" ");
+  rx_pktbuf = &(ctx->rx_pktbuf);
+  rx_pktbuf->size_req = size;
+  result = rx_doorways(ctx, rx_pktbuf, error);
+  if (result == 2)
+    {
+    result = -1;
+    g_set_error (error, G_IO_ERROR, G_IO_ERROR_WOULD_BLOCK, "fd would block");
+    }
+  else if (result != -1)
+    { 
+    if (result != 5)
+      KERR("%d %d %d %d", result, rx_pktbuf->paylen, rx_pktbuf->offset, 
+                          rx_pktbuf->paylen_given);
+    else
+      {
+      left_to_give = rx_pktbuf->offset - headsize - rx_pktbuf->paylen_given; 
+      if (left_to_give < 0) 
+        KOUT("%d", left_to_give);
+      if (size < left_to_give)
+        len_to_give = size;
+      else
+        len_to_give = left_to_give;
+      result = len_to_give;
+      if (result == 0)
+        {
+        result = -1;
+        g_set_error (error, G_IO_ERROR, G_IO_ERROR_WOULD_BLOCK, "fd would block");
+        KERR("%d %d %d", rx_pktbuf->paylen, rx_pktbuf->offset, 
+                         rx_pktbuf->paylen_given);
+        }
+      else
+        {
+        memcpy(buffer, rx_pktbuf->payload + rx_pktbuf->paylen_given, len_to_give);
+        rx_pktbuf->paylen_given += len_to_give;
+        if (rx_pktbuf->paylen_given == rx_pktbuf->paylen)
+          {
+          rx_pktbuf->offset = 0;
+          rx_pktbuf->paylen = 0;
+          rx_pktbuf->paylen_given = 0;
+          rx_pktbuf->payload = NULL;
+          rx_pktbuf->dido_llid = 0;
+          rx_pktbuf->type = 0;
+          rx_pktbuf->val = 0;
+          }
+        }
+      }
+    }
+  return result;
+}
+/*--------------------------------------------------------------------------*/
+
+
+
diff -Naur spice-gtk/src/cloon.h tainted_spice/src/cloon.h
--- spice-gtk/src/cloon.h	1970-01-01 01:00:00.000000000 +0100
+++ tainted_spice/src/cloon.h	2022-07-14 09:22:54.461154914 +0200
@@ -0,0 +1,22 @@
+
+
+#include <syslog.h>
+#include "../../../../common/glob_include/glob_common.h"
+
+
+#define MAX_FD_NUMBER_CTX  100
+
+
+/*--------------------------------------------------------------------------*/
+void cloonix_preliminaries(char *password, GSocket *gsock, int sock, char *spice_sock);
+/*--------------------------------------------------------------------------*/
+gssize cloonix_g_socket_send (GSocket *socket, const gchar *buffer,
+                              gsize size, GCancellable *cancellable,
+                              GError **error);
+/*--------------------------------------------------------------------------*/
+gssize cloonix_g_socket_receive(GSocket *socket, gchar *buffer, gsize size,
+                                GCancellable *cancellable, GError **error);
+/*--------------------------------------------------------------------------*/
+int get_address_from_param(char *param, char *ip, int *port);
+/*--------------------------------------------------------------------------*/
+
diff -Naur spice-gtk/src/hmac_cipher.c tainted_spice/src/hmac_cipher.c
--- spice-gtk/src/hmac_cipher.c	1970-01-01 01:00:00.000000000 +0100
+++ tainted_spice/src/hmac_cipher.c	2022-07-14 09:22:54.461154914 +0200
@@ -0,0 +1,144 @@
+/*****************************************************************************/
+/*    Copyright (C) 2006-2022 clownix@clownix.net License AGPL-3             */
+/*                                                                           */
+/*  This program is free software: you can redistribute it and/or modify     */
+/*  it under the terms of the GNU Affero General Public License as           */
+/*  published by the Free Software Foundation, either version 3 of the       */
+/*  License, or (at your option) any later version.                          */
+/*                                                                           */
+/*  This program is distributed in the hope that it will be useful,          */
+/*  but WITHOUT ANY WARRANTY; without even the implied warranty of           */
+/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
+/*  GNU Affero General Public License for more details.a                     */
+/*                                                                           */
+/*  You should have received a copy of the GNU Affero General Public License */
+/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.    */
+/*                                                                           */
+/*****************************************************************************/
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <errno.h>
+
+#include <openssl/hmac.h>
+#include <openssl/evp.h>
+#include "hmac_cipher.h"
+
+#include <syslog.h>
+#define KOUT(format, a...)                               \
+ do {                                                    \
+    printf("\n%s %s line:%d   " format,         \
+    __FILE__,__FUNCTION__,__LINE__, ## a);               \
+    syslog(LOG_ERR, "%s %s line:%d   " format, \
+    __FILE__,__FUNCTION__,__LINE__, ## a);               \
+    exit(-1);                                            \
+    } while (0)
+
+static unsigned char glob_key[MSG_DIGEST_LEN];
+static const EVP_MD *md_hmac_sha;
+static EVP_CIPHER_CTX *cipher_ctx;
+
+/*****************************************************************************/
+char *compute_msg_digest(int len, char *data)
+{
+  unsigned char *md;
+  unsigned int md_len;
+  md = HMAC(md_hmac_sha, ( unsigned char *)glob_key, MSG_DIGEST_LEN, 
+            (const unsigned char *) data, (unsigned int) len, NULL, &md_len);
+  if (md_len != MSG_DIGEST_LEN)
+    KOUT("%d %d", (int) md_len, (int) MSG_DIGEST_LEN);
+  return (char *)md;
+}
+/*---------------------------------------------------------------------------*/
+
+/*****************************************************************************/
+static int cipher( int do_encrypt, unsigned char *iv, 
+            int inlen, unsigned char *inbuf,
+            unsigned char *outbuf)
+{
+  int len, tot_len = 0;
+  EVP_CIPHER_CTX_init(cipher_ctx);
+  EVP_CipherInit_ex(cipher_ctx, EVP_aes_256_cbc(), NULL, 
+                    glob_key, iv, do_encrypt);
+  EVP_CIPHER_CTX_set_key_length(cipher_ctx, MSG_DIGEST_LEN);
+  if (EVP_CipherUpdate(cipher_ctx, outbuf, &len, inbuf, inlen))
+    {
+    tot_len += len;
+    if (EVP_CipherFinal_ex(cipher_ctx, outbuf+tot_len, &len))
+      tot_len += len;
+    }
+  EVP_CIPHER_CTX_cleanup(cipher_ctx);
+  return tot_len;
+}
+/*---------------------------------------------------------------------------*/
+
+/*****************************************************************************/
+int hmac_extract_and_decipher(int len, char *buf, char **outbuf)
+{
+  int outlen = 0;
+  char *md = buf;
+  char *md_check;
+  *outbuf = NULL;
+  if (len > MSG_DIGEST_LEN)
+    {
+    *outbuf = (char *) malloc(len);
+    outlen = cipher( 0, (unsigned char *) md, len-MSG_DIGEST_LEN, 
+    (unsigned char *) (buf+MSG_DIGEST_LEN), (unsigned char *) (*outbuf));   
+    if (!outlen)
+      {
+      free(*outbuf);
+      *outbuf = NULL;
+      }
+    else
+      {
+      md_check = compute_msg_digest(outlen, *outbuf);
+      if (memcmp(md_check, md, MSG_DIGEST_LEN))
+        {
+        free(*outbuf);
+        *outbuf = NULL;
+        outlen = 0;
+        }
+      }
+    }
+  return outlen;
+}
+/*---------------------------------------------------------------------------*/
+
+/*****************************************************************************/
+int hmac_insert_and_cipher(int len, char *buf, char **outbuf)
+{
+  int outlen, max_len;
+  char *md = compute_msg_digest(len, buf);
+  max_len = len + 2*MSG_DIGEST_LEN;
+  *outbuf = (char *) malloc(max_len);
+  memcpy(*outbuf, md, MSG_DIGEST_LEN);
+  outlen = cipher( 1, (unsigned char *) md, len, 
+           (unsigned char *) buf, (unsigned char *) (*outbuf+MSG_DIGEST_LEN)); 
+  if (!outlen)
+    {
+    free(*outbuf);
+    *outbuf = NULL;
+    }
+  else
+    outlen += MSG_DIGEST_LEN;
+  return outlen;
+}
+/*---------------------------------------------------------------------------*/
+
+/*****************************************************************************/
+void cipher_myinit(char *key)
+{
+  cipher_ctx = EVP_CIPHER_CTX_new();
+  if ((strlen(key) < 2) || (strlen(key) >= MSG_DIGEST_LEN))
+    KOUT("%d %s", (int) (strlen(key)), key);
+  memset(glob_key, 0, MSG_DIGEST_LEN);
+  memcpy(glob_key, key, strlen(key));
+  OpenSSL_add_all_digests();
+  md_hmac_sha = EVP_get_digestbyname("SHA256");
+  if(!md_hmac_sha)
+    KOUT("Unknown message digest \"SHA256\"");
+}
+/*---------------------------------------------------------------------------*/
+
+
diff -Naur spice-gtk/src/hmac_cipher.h tainted_spice/src/hmac_cipher.h
--- spice-gtk/src/hmac_cipher.h	1970-01-01 01:00:00.000000000 +0100
+++ tainted_spice/src/hmac_cipher.h	2022-07-14 09:22:54.461154914 +0200
@@ -0,0 +1,28 @@
+/*****************************************************************************/
+/*    Copyright (C)  2006-2022    Cloon,    <clownix@clownix.net>          */
+/*****************************************************************************/
+/*                                                                           */
+/*    This program is free software: you can redistribute it and/or modify   */
+/*    it under the terms of the GNU General Public License as published by   */
+/*    the Free Software Foundation, either version 3 of the License, or      */
+/*    (at your option) any later version.                                    */
+/*                                                                           */
+/*    This program is distributed in the hope that it will be useful,        */
+/*    but WITHOUT ANY WARRANTY; without even the implied warranty of         */
+/*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          */
+/*    GNU General Public License for more details.                           */
+/*                                                                           */
+/*    You should have received a copy of the GNU General Public License      */
+/*    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+/*                                                                           */
+/*****************************************************************************/
+#define MSG_DIGEST_LEN 32
+#define DOORWAYS_HEADER_SIZE (16+MSG_DIGEST_LEN)
+char *compute_msg_digest(int len, char *data);
+int hmac_extract_and_decipher(int len, char *buf, char **outbuf);
+int hmac_insert_and_cipher(int len, char *buf, char **outbuf);
+void cipher_myinit(char *key);
+/*---------------------------------------------------------------------------*/
+
+
+
diff -Naur spice-gtk/src/meson.build tainted_spice/src/meson.build
--- spice-gtk/src/meson.build	2022-07-14 09:19:52.000000000 +0200
+++ tainted_spice/src/meson.build	2022-07-14 09:22:54.461154914 +0200
@@ -85,6 +85,8 @@
   'spice-client.c',
   'spice-option.c',
   'spice-session.c',
+  'cloon.c',
+  'hmac_cipher.c',
   'spice-util.c',
   'usb-device-manager.c',
 ]
diff -Naur spice-gtk/src/spice-channel.c tainted_spice/src/spice-channel.c
--- spice-gtk/src/spice-channel.c	2022-07-14 09:19:52.000000000 +0200
+++ tainted_spice/src/spice-channel.c	2022-07-14 09:22:54.461154914 +0200
@@ -48,6 +48,11 @@
 
 G_STATIC_ASSERT(sizeof(SpiceChannelClass) == sizeof(GObjectClass) + 19 * sizeof(gpointer));
 
+/*CLOON*/
+#include "cloon.h"
+/*CLOON*/
+
+
 static void spice_channel_handle_msg(SpiceChannel *channel, SpiceMsgIn *msg);
 static void spice_channel_write_msg(SpiceChannel *channel, SpiceMsgOut *out);
 static void spice_channel_send_link(SpiceChannel *channel);
@@ -802,8 +807,9 @@
         }
     } else {
         GError *error = NULL;
-        ret = g_pollable_output_stream_write_nonblocking(G_POLLABLE_OUTPUT_STREAM(c->out),
-                                                         ptr, len, NULL, &error);
+
+        ret = cloonix_g_socket_send(c->sock, ptr, len, NULL, &error);
+
         if (ret < 0) {
             if (g_error_matches(error, G_IO_ERROR, G_IO_ERROR_WOULD_BLOCK)) {
                 *cond = G_IO_OUT;
@@ -1023,8 +1029,9 @@
         }
     } else {
         GError *error = NULL;
-        ret = g_pollable_input_stream_read_nonblocking(G_POLLABLE_INPUT_STREAM(c->in),
-                                                       data, len, NULL, &error);
+
+	ret = cloonix_g_socket_receive(c->sock, data, len, NULL, &error);
+
         if (ret < 0) {
             if (g_error_matches(error, G_IO_ERROR, G_IO_ERROR_WOULD_BLOCK)) {
                 *cond = G_IO_IN;
@@ -2268,6 +2275,7 @@
 
     g_return_val_if_fail(s != NULL, NULL);
 
+
     switch (type) {
     case SPICE_CHANNEL_MAIN:
         gtype = SPICE_TYPE_MAIN_CHANNEL;
@@ -2347,7 +2355,6 @@
 void spice_channel_destroy(SpiceChannel *channel)
 {
     g_return_if_fail(channel != NULL);
-
     CHANNEL_DEBUG(channel, "channel destroy");
     spice_channel_disconnect(channel, SPICE_CHANNEL_NONE);
     g_object_unref(channel);
@@ -2592,20 +2599,17 @@
             c->event = SPICE_CHANNEL_ERROR_CONNECT;
             goto cleanup;
         }
-
         if (!(c->sock = g_socket_new_from_fd(c->fd, NULL))) {
                 CHANNEL_DEBUG(channel, "Failed to open socket from fd %d", c->fd);
                 c->event = SPICE_CHANNEL_ERROR_CONNECT;
                 goto cleanup;
         }
-
         g_socket_set_blocking(c->sock, FALSE);
         g_socket_set_keepalive(c->sock, TRUE);
         c->conn = g_socket_connection_factory_create_connection(c->sock);
         goto connected;
     }
 
-
 reconnect:
     c->conn = spice_session_channel_open_host(c->session, channel, &c->tls, &c->error);
     if (c->conn == NULL) {
diff -Naur spice-gtk/src/spice-gstaudio.c tainted_spice/src/spice-gstaudio.c
--- spice-gtk/src/spice-gstaudio.c	2022-07-14 09:19:52.000000000 +0200
+++ tainted_spice/src/spice-gstaudio.c	2022-07-14 09:22:54.465155083 +0200
@@ -349,46 +349,6 @@
 
 #define VOLUME_NORMAL 65535
 
-static void playback_volume_changed(GObject *object, GParamSpec *pspec, gpointer data)
-{
-    SpiceGstaudio *gstaudio = data;
-    GstElement *e = NULL;
-    guint16 *volume;
-    guint nchannels;
-    SpiceGstaudioPrivate *p = gstaudio->priv;
-    gdouble vol;
-
-    if (!p->playback.sink)
-        return;
-
-    g_object_get(object,
-                 "volume", &volume,
-                 "nchannels", &nchannels,
-                 NULL);
-
-    g_return_if_fail(nchannels > 0);
-
-    vol = 1.0 * volume[0] / VOLUME_NORMAL;
-    SPICE_DEBUG("playback volume changed to %u (%0.2f)", volume[0], 100*vol);
-
-    if (GST_IS_BIN(p->playback.sink))
-        e = gst_bin_get_by_interface(GST_BIN(p->playback.sink), GST_TYPE_STREAM_VOLUME);
-    if (!e)
-        e = g_object_ref(p->playback.sink);
-
-    /* Double check to make compiler happy */
-    g_return_if_fail(e != NULL);
-
-    if (GST_IS_STREAM_VOLUME(e)) {
-        gst_stream_volume_set_volume(GST_STREAM_VOLUME(e), GST_STREAM_VOLUME_FORMAT_CUBIC, vol);
-    } else if (g_object_class_find_property(G_OBJECT_GET_CLASS (e), "volume") != NULL) {
-        g_object_set(e, "volume", vol, NULL);
-    } else {
-        g_warning("playback: ignoring volume change on %s", gst_element_get_name(e));
-    }
-
-    g_object_unref(e);
-}
 
 static void playback_mute_changed(GObject *object, GParamSpec *pspec, gpointer data)
 {
@@ -413,55 +373,16 @@
 
     if (GST_IS_STREAM_VOLUME(e)) {
         gst_stream_volume_set_mute(GST_STREAM_VOLUME(e), mute);
-    } else if (g_object_class_find_property(G_OBJECT_GET_CLASS (e), "mute") != NULL) {
-        g_object_set(e, "mute", mute, NULL);
-    } else {
-        g_warning("playback: ignoring mute change on %s", gst_element_get_name(e));
     }
+// else if (g_object_class_find_property(G_OBJECT_GET_CLASS (e), "mute") != NULL) {
+//        g_object_set(e, "mute", mute, NULL);
+//    } else {
+//        g_warning("playback: ignoring mute change on %s", gst_element_get_name(e));
+//    }
 
     g_object_unref(e);
 }
 
-static void record_volume_changed(GObject *object, GParamSpec *pspec, gpointer data)
-{
-    SpiceGstaudio *gstaudio = data;
-    SpiceGstaudioPrivate *p = gstaudio->priv;
-    GstElement *e = NULL;
-    guint16 *volume;
-    guint nchannels;
-    gdouble vol;
-
-    if (!p->record.src)
-        return;
-
-    g_object_get(object,
-                 "volume", &volume,
-                 "nchannels", &nchannels,
-                 NULL);
-
-    g_return_if_fail(nchannels > 0);
-
-    vol = 1.0 * volume[0] / VOLUME_NORMAL;
-    SPICE_DEBUG("record volume changed to %u (%0.2f)", volume[0], 100*vol);
-
-    if (GST_IS_BIN(p->record.src))
-        e = gst_bin_get_by_interface(GST_BIN(p->record.src), GST_TYPE_STREAM_VOLUME);
-    if (!e)
-        e = g_object_ref(p->record.src);
-
-    /* Double check to make compiler happy */
-    g_return_if_fail(e != NULL);
-
-    if (GST_IS_STREAM_VOLUME(e)) {
-        gst_stream_volume_set_volume(GST_STREAM_VOLUME(e), GST_STREAM_VOLUME_FORMAT_CUBIC, vol);
-    } else if (g_object_class_find_property(G_OBJECT_GET_CLASS (e), "volume") != NULL) {
-        g_object_set(e, "volume", vol, NULL);
-    } else {
-        g_warning("record: ignoring volume change on %s", gst_element_get_name(e));
-    }
-
-    g_object_unref(e);
-}
 
 static void record_mute_changed(GObject *object, GParamSpec *pspec, gpointer data)
 {
@@ -486,11 +407,12 @@
 
     if (GST_IS_STREAM_VOLUME (e)) {
         gst_stream_volume_set_mute(GST_STREAM_VOLUME(e), mute);
-    } else if (g_object_class_find_property(G_OBJECT_GET_CLASS (e), "mute") != NULL) {
-        g_object_set(e, "mute", mute, NULL);
-    } else {
-        g_warning("record: ignoring mute change on %s", gst_element_get_name(e));
     }
+// else if (g_object_class_find_property(G_OBJECT_GET_CLASS (e), "mute") != NULL) {
+//        g_object_set(e, "mute", mute, NULL);
+//    } else {
+//        g_warning("record: ignoring mute change on %s", gst_element_get_name(e));
+//    }
 
     g_object_unref(e);
 }
@@ -529,8 +451,6 @@
                                       G_CALLBACK(playback_data), gstaudio, 0);
         spice_g_signal_connect_object(channel, "playback-stop",
                                       G_CALLBACK(playback_stop), gstaudio, G_CONNECT_SWAPPED);
-        spice_g_signal_connect_object(channel, "notify::volume",
-                                      G_CALLBACK(playback_volume_changed), gstaudio, 0);
         spice_g_signal_connect_object(channel, "notify::mute",
                                       G_CALLBACK(playback_mute_changed), gstaudio, 0);
 
@@ -546,8 +466,6 @@
                                       G_CALLBACK(record_start), gstaudio, 0);
         spice_g_signal_connect_object(channel, "record-stop",
                                       G_CALLBACK(record_stop), gstaudio, G_CONNECT_SWAPPED);
-        spice_g_signal_connect_object(channel, "notify::volume",
-                                      G_CALLBACK(record_volume_changed), gstaudio, 0);
         spice_g_signal_connect_object(channel, "notify::mute",
                                       G_CALLBACK(record_mute_changed), gstaudio, 0);
 
@@ -581,8 +499,8 @@
             if (major < 1 ||
                 (major == 1 && minor < 14) ||
                 (major == 1 && minor == 14 && micro < 5)) {
-                g_warning("Bad pulsesrc version %s, lowering its rank",
-                          gst_plugin_get_version(plugin));
+//                g_warning("Bad pulsesrc version %s, lowering its rank",
+//                          gst_plugin_get_version(plugin));
                 gst_plugin_feature_set_rank(pulsesrc, GST_RANK_NONE);
             }
 
@@ -622,8 +540,8 @@
 {
     SpiceGstaudioPrivate *p = SPICE_GSTAUDIO(audio)->priv;
     GstElement *e = NULL;
-    gboolean lmute;
-    gdouble vol;
+    gboolean lmute = FALSE;
+    gdouble vol = 0;
     GTask *task = G_TASK(res);
 
     g_return_val_if_fail(g_task_is_valid(task, audio), FALSE);
@@ -651,11 +569,12 @@
     if (GST_IS_STREAM_VOLUME(e)) {
         vol = gst_stream_volume_get_volume(GST_STREAM_VOLUME(e), GST_STREAM_VOLUME_FORMAT_CUBIC);
         lmute = gst_stream_volume_get_mute(GST_STREAM_VOLUME(e));
-    } else {
-        g_object_get(e,
-                     "volume", &vol,
-                     "mute", &lmute, NULL);
     }
+// else {
+//        g_object_get(e,
+//                     "volume", &vol,
+//                     "mute", &lmute, NULL);
+//    }
     g_object_unref(e);
 
     if (p->playback.fake) {
@@ -705,8 +624,8 @@
 {
     SpiceGstaudioPrivate *p = SPICE_GSTAUDIO(audio)->priv;
     GstElement *e = NULL;
-    gboolean lmute;
-    gdouble vol;
+    gboolean lmute = FALSE;
+    gdouble vol = 0;
     gboolean fake_channel = FALSE;
     GTask *task = G_TASK(res);
 
@@ -735,11 +654,12 @@
     if (GST_IS_STREAM_VOLUME(e)) {
         vol = gst_stream_volume_get_volume(GST_STREAM_VOLUME(e), GST_STREAM_VOLUME_FORMAT_CUBIC);
         lmute = gst_stream_volume_get_mute(GST_STREAM_VOLUME(e));
-    } else {
-        g_object_get(e,
-                     "volume", &vol,
-                     "mute", &lmute, NULL);
     }
+// else {
+//        g_object_get(e,
+//                     "volume", &vol,
+//                     "mute", &lmute, NULL);
+//    }
     g_object_unref(e);
 
     if (fake_channel) {
diff -Naur spice-gtk/src/spice-session.c tainted_spice/src/spice-session.c
--- spice-gtk/src/spice-session.c	2022-07-14 09:19:52.000000000 +0200
+++ tainted_spice/src/spice-session.c	2022-07-14 09:22:54.465155083 +0200
@@ -20,9 +20,8 @@
 #include <gio/gnetworking.h>
 #include <gio/gio.h>
 #include <glib.h>
-#ifdef G_OS_UNIX
 #include <gio/gunixsocketaddress.h>
-#endif
+#include "cloon.h"
 
 #include "spice-client.h"
 #include "spice-common.h"
@@ -43,11 +42,14 @@
 #define TCP_KEEPIDLE TCP_KEEPALIVE
 #endif
 
+
 #define IMAGES_CACHE_SIZE_DEFAULT (1024 * 1024 * 80)
 #define MIN_GLZ_WINDOW_SIZE_DEFAULT (1024 * 1024 * 12)
 #define MAX_GLZ_WINDOW_SIZE_DEFAULT MIN((LZ_MAX_WINDOW_SIZE * 4), 1024 * 1024 * 64)
 
 struct _SpiceSessionPrivate {
+    char              *cloonix_doors;
+    char              *cloonix_spice;
     char              *host;
     char              *unix_path;
     char              *port;
@@ -165,6 +167,8 @@
 /* Properties */
 enum {
     PROP_0,
+    PROP_CLOONIX_DOORS,
+    PROP_CLOONIX_SPICE,
     PROP_HOST,
     PROP_PORT,
     PROP_TLS_PORT,
@@ -357,6 +361,8 @@
     SpiceSessionPrivate *s = session->priv;
 
     /* release stuff */
+    g_free(s->cloonix_doors);
+    g_free(s->cloonix_spice);
     g_free(s->unix_path);
     g_free(s->host);
     g_free(s->port);
@@ -397,6 +403,10 @@
         return g_strdup_printf(URI_SCHEME_SPICE_UNIX "%s", s->unix_path);
     } else if (s->host != NULL) {
         const char *port, *scheme;
+
+//cloon suppress errors
+return NULL;
+
         g_return_val_if_fail(s->port != NULL || s->tls_port != NULL, NULL);
 
         if (s->tls_port && s->port) {
@@ -422,7 +432,9 @@
 static int spice_parse_uri(SpiceSession *session, const char *original_uri)
 {
     SpiceSessionPrivate *s = session->priv;
-    gchar *host = NULL, *port = NULL, *tls_port = NULL, *uri = NULL, *username = NULL, *password = NULL;
+    gchar *host = NULL, *port = NULL, *tls_port = NULL;
+    gchar *uri = NULL, *username = NULL, *password = NULL;
+    gchar *cloonix_doors = NULL, *cloonix_spice = NULL;
     gchar *path = NULL;
     gchar *authority = NULL;
     gchar *query = NULL;
@@ -544,7 +556,11 @@
         }
 
         target_key = NULL;
-        if (g_str_equal(key, "port")) {
+        if (g_str_equal(key, "cloonix-doors")) {
+            target_key = &cloonix_doors;
+        } else if (g_str_equal(key, "cloonix-spice")) {
+            target_key = &cloonix_spice;
+        } else if (g_str_equal(key, "port")) {
             target_key = &port;
         } else if (g_str_equal(key, "tls-port")) {
             target_key = &tls_port;
@@ -564,13 +580,15 @@
         }
     }
 
-    if (port == NULL && tls_port == NULL) {
-        g_warning("Missing port or tls-port in spice URI '%s'", original_uri);
-        goto fail;
-    }
+//    if (port == NULL && tls_port == NULL) {
+//        g_warning("Missing port or tls-port in spice URI '%s'", original_uri);
+//        goto fail;
+//    }
 
 end:
     /* parsed ok -> apply */
+    g_free(s->cloonix_doors);
+    g_free(s->cloonix_spice);
     g_free(s->unix_path);
     g_free(s->host);
     g_free(s->port);
@@ -588,6 +606,8 @@
     }
     s->username = username;
     s->password = password;
+    s->cloonix_doors = cloonix_doors;
+    s->cloonix_spice = cloonix_spice;
     return 0;
 
 fail:
@@ -597,6 +617,8 @@
     g_free(tls_port);
     g_free(username);
     g_free(password);
+    g_free(cloonix_doors);
+    g_free(cloonix_spice);
     return -1;
 }
 
@@ -609,6 +631,14 @@
     SpiceSessionPrivate *s = session->priv;
 
     switch (prop_id) {
+
+    case PROP_CLOONIX_DOORS:
+        g_value_set_string(value, s->cloonix_doors);
+        break;
+    case PROP_CLOONIX_SPICE:
+        g_value_set_string(value, s->cloonix_spice);
+        break;
+
     case PROP_HOST:
         g_value_set_string(value, s->host);
 	break;
@@ -733,6 +763,16 @@
     const char *str;
 
     switch (prop_id) {
+
+    case PROP_CLOONIX_DOORS:
+        g_free(s->cloonix_doors);
+        s->cloonix_doors = g_value_dup_string(value);
+        break;
+    case PROP_CLOONIX_SPICE:
+        g_free(s->cloonix_spice);
+        s->cloonix_spice = g_value_dup_string(value);
+        break;
+
     case PROP_HOST:
         g_free(s->host);
         s->host = g_value_dup_string(value);
@@ -878,6 +918,42 @@
     gobject_class->get_property = spice_session_get_property;
     gobject_class->set_property = spice_session_set_property;
 
+
+    /**
+     * SpiceSession:cloonix_doors:
+     *
+     * Add of the cloon server to connect to
+     *
+     **/
+    g_object_class_install_property
+        (gobject_class, PROP_CLOONIX_DOORS,
+         g_param_spec_string("cloonix-doors",
+                             "cloonix-doors",
+                             "cloonix-doors",
+                             NULL,
+                             G_PARAM_READWRITE |
+                             G_PARAM_CONSTRUCT |
+                             G_PARAM_STATIC_STRINGS));
+
+
+    /**
+     * SpiceSession:cloonix_spice:
+     *
+     * Unix socket access of the spice inside the cloon server
+     *
+     **/
+    g_object_class_install_property
+        (gobject_class, PROP_CLOONIX_SPICE,
+         g_param_spec_string("cloonix-spice",
+                             "cloonix-spice",
+                             "cloonix-spice",
+                             NULL,
+                             G_PARAM_READWRITE |
+                             G_PARAM_CONSTRUCT |
+                             G_PARAM_STATIC_STRINGS));
+
+
+
     /**
      * SpiceSession:host:
      *
@@ -1605,6 +1681,8 @@
     c = copy->priv;
     g_clear_object(&c->proxy);
 
+    g_warn_if_fail(c->cloonix_doors == NULL);
+    g_warn_if_fail(c->cloonix_spice == NULL);
     g_warn_if_fail(c->host == NULL);
     g_warn_if_fail(c->unix_path == NULL);
     g_warn_if_fail(c->tls_port == NULL);
@@ -1618,6 +1696,8 @@
     g_warn_if_fail(c->proxy == NULL);
 
     g_object_get(session,
+                 "cloonix-doors", &c->cloonix_doors,
+                 "cloonix-spice", &c->cloonix_spice,
                  "host", &c->host,
                  "unix-path", &c->unix_path,
                  "tls-port", &c->tls_port,
@@ -2100,14 +2180,37 @@
     GSocketClient *client = G_SOCKET_CLIENT(source_object);
     spice_open_host *open_host = data;
     GSocketConnection *connection = NULL;
+    GSocket *gsock;
+    int sock;
+    int is_connected;
+    char *cloonix_spice;
+    char *password;
+
+    if (open_host->connection != NULL)
+      {
+      syslog(LOG_ERR, "TWO CONNECTS FOR ONE REQUEST");
+      exit(-1);
+      }
 
     CHANNEL_DEBUG(open_host->channel, "connect ready");
-    connection = g_socket_client_connect_finish(client, result, &open_host->error);
+    connection = g_socket_client_connect_finish(client, result, 
+                                                &open_host->error);
     if (connection == NULL) {
         g_warn_if_fail(open_host->error != NULL);
         goto end;
     }
-
+    is_connected = g_socket_connection_is_connected(connection);
+    gsock = g_socket_connection_get_socket(connection);
+    sock = g_socket_get_fd(gsock);
+  if ((!is_connected) || (!gsock) || (sock <= 0))
+    {
+    syslog(LOG_ERR, "%s CONNECT PB %d %p %d", __FUNCTION__, 
+                    is_connected, gsock, sock);
+    exit(-1);
+    }
+    cloonix_spice =(char *)spice_session_get_cloonix_spice(open_host->session);
+    password = (char *) spice_session_get_password(open_host->session);
+    cloonix_preliminaries(password, gsock, sock, cloonix_spice);
     open_host->connection = connection;
 
 end:
@@ -2115,10 +2218,12 @@
 }
 
 /* main context */
-static void open_host_connectable_connect(spice_open_host *open_host, GSocketConnectable *connectable)
+static void open_host_connectable_connect(spice_open_host *open_host, 
+                                          GSocketConnectable *connectable)
 {
     CHANNEL_DEBUG(open_host->channel, "connecting %p...", open_host);
 
+    open_host->connection = NULL;
     g_socket_client_connect_async(open_host->client, connectable,
                                   open_host->cancellable,
                                   socket_client_connect_ready, open_host);
@@ -2164,6 +2269,12 @@
 {
     spice_open_host *open_host = data;
     SpiceSessionPrivate *s;
+    GInetAddress *ip_addr;
+    GSocketAddress *address = NULL;
+//    GSocketConnectable *address = NULL;
+    char doors_ip[100];
+    int doors_port;
+
 
     g_return_val_if_fail(open_host != NULL, FALSE);
     g_return_val_if_fail(open_host->connection == NULL, FALSE);
@@ -2183,28 +2294,19 @@
                                         spice_uri_get_hostname(open_host->proxy),
                                         open_host->cancellable,
                                         proxy_lookup_ready, open_host);
-    } else {
-        GSocketConnectable *address = NULL;
-
-        if (s->unix_path) {
-            SPICE_DEBUG("open unix path %s", s->unix_path);
-#ifdef G_OS_UNIX
-            address = G_SOCKET_CONNECTABLE(g_unix_socket_address_new(s->unix_path));
-#else
-            g_set_error_literal(&open_host->error, SPICE_CLIENT_ERROR, SPICE_CLIENT_ERROR_FAILED,
-                                "Unix path unsupported on this platform");
-#endif
-        } else {
-            SPICE_DEBUG("open host %s:%d", s->host, open_host->port);
-            address = g_network_address_parse(s->host, open_host->port, &open_host->error);
-        }
-
-        if (address == NULL || open_host->error != NULL) {
-            coroutine_yieldto(open_host->from, NULL);
-            return FALSE;
-        }
-
-        open_host_connectable_connect(open_host, address);
+    } 
+    else {
+        if (get_address_from_param(s->cloonix_doors, doors_ip, &doors_port))
+            {
+            ip_addr = g_inet_address_new_from_string(doors_ip);
+            address = g_inet_socket_address_new(ip_addr, doors_port);
+            }
+        else
+            {
+            syslog(LOG_ERR, "%s", s->cloonix_doors);
+            exit(-1);
+            }
+        open_host_connectable_connect(open_host, G_SOCKET_CONNECTABLE(address));
         g_object_unref(address);
     }
 
@@ -2221,15 +2323,18 @@
 
 /* coroutine context */
 G_GNUC_INTERNAL
-GSocketConnection* spice_session_channel_open_host(SpiceSession *session, SpiceChannel *channel,
-                                                   gboolean *use_tls, GError **error)
+GSocketConnection* spice_session_channel_open_host(SpiceSession *session, 
+                                                   SpiceChannel *channel,
+                                                   gboolean *use_tls, 
+                                                   GError **error)
 {
     g_return_val_if_fail(SPICE_IS_SESSION(session), NULL);
 
     SpiceSessionPrivate *s = session->priv;
     SpiceChannelPrivate *c = channel->priv;
     spice_open_host open_host = { 0, };
-    gchar *port, *endptr;
+ //   gchar *port, *endptr;
+
 
     // FIXME: make open_host() cancellable
     open_host.from = coroutine_self();
@@ -2241,31 +2346,6 @@
         spice_strv_contains(s->secure_channels, name))
         *use_tls = TRUE;
 
-    if (s->unix_path) {
-        if (*use_tls) {
-            CHANNEL_DEBUG(channel, "No TLS for Unix sockets");
-            return NULL;
-        }
-    } else {
-        port = *use_tls ? s->tls_port : s->port;
-        if (port == NULL) {
-            SPICE_DEBUG("Missing port value, not attempting %s connection.",
-                    *use_tls?"TLS":"unencrypted");
-            return NULL;
-        }
-
-        open_host.port = strtol(port, &endptr, 10);
-        if (*port == '\0' || *endptr != '\0' ||
-            open_host.port <= 0 || open_host.port > G_MAXUINT16) {
-            g_warning("Invalid port value %s", port);
-            return NULL;
-        }
-    }
-    if (*use_tls) {
-        CHANNEL_DEBUG(channel, "Using TLS, port %d", open_host.port);
-    } else {
-        CHANNEL_DEBUG(channel, "Using plain text, port %d", open_host.port);
-    }
 
     open_host.client = g_socket_client_new();
     g_socket_client_set_enable_proxy(open_host.client, s->proxy != NULL);
@@ -2524,6 +2604,27 @@
 }
 
 G_GNUC_INTERNAL
+const gchar* spice_session_get_cloonix_doors(SpiceSession *session)
+{
+    g_return_val_if_fail(SPICE_IS_SESSION(session), NULL);
+
+    SpiceSessionPrivate *s = session->priv;
+
+    return s->cloonix_doors;
+}
+
+G_GNUC_INTERNAL
+const gchar* spice_session_get_cloonix_spice(SpiceSession *session)
+{
+    g_return_val_if_fail(SPICE_IS_SESSION(session), NULL);
+
+    SpiceSessionPrivate *s = session->priv;
+
+    return s->cloonix_spice;
+}
+
+
+G_GNUC_INTERNAL
 const gchar* spice_session_get_host(SpiceSession *session)
 {
     g_return_val_if_fail(SPICE_IS_SESSION(session), NULL);
diff -Naur spice-gtk/src/spice-session-priv.h tainted_spice/src/spice-session-priv.h
--- spice-gtk/src/spice-session-priv.h	2022-07-14 09:19:52.000000000 +0200
+++ tainted_spice/src/spice-session-priv.h	2022-07-14 09:22:54.465155083 +0200
@@ -59,6 +59,8 @@
 void spice_session_get_pubkey(SpiceSession *session, guint8 **pubkey, guint *size);
 guint spice_session_get_verify(SpiceSession *session);
 const gchar* spice_session_get_username(SpiceSession *session);
+const gchar* spice_session_get_cloonix_doors(SpiceSession *session);
+const gchar* spice_session_get_cloonix_spice(SpiceSession *session);
 const gchar* spice_session_get_password(SpiceSession *session);
 const gchar* spice_session_get_host(SpiceSession *session);
 const gchar* spice_session_get_cert_subject(SpiceSession *session);
diff -Naur spice-gtk/src/spice-widget-egl.c tainted_spice/src/spice-widget-egl.c
--- spice-gtk/src/spice-widget-egl.c	2022-07-14 09:19:52.000000000 +0200
+++ tainted_spice/src/spice-widget-egl.c	2022-07-14 09:22:54.465155083 +0200
@@ -218,7 +218,7 @@
 #endif
 
     d->egl.display = eglGetDisplay(dpy);
-    if (d->egl.display == EGL_NO_DISPLAY) {
+    if (d->egl.display == 0) {
         g_set_error_literal(err, SPICE_CLIENT_ERROR, SPICE_CLIENT_ERROR_FAILED,
                             "failed to get EGL display");
         return FALSE;
@@ -256,7 +256,7 @@
 
     d->egl.ctx = eglCreateContext(d->egl.display,
                                   d->egl.conf,
-                                  EGL_NO_CONTEXT,
+                                  0,
                                   ctx_att);
     if (!d->egl.ctx) {
         g_set_error_literal(err, SPICE_CLIENT_ERROR, SPICE_CLIENT_ERROR_FAILED,
@@ -264,7 +264,7 @@
         return FALSE;
     }
 
-    eglMakeCurrent(d->egl.display, EGL_NO_SURFACE, EGL_NO_SURFACE,
+    eglMakeCurrent(d->egl.display, 0, 0,
                    d->egl.ctx);
 
 #ifdef GDK_WINDOWING_WAYLAND
@@ -405,9 +405,9 @@
         /* egl.surface && egl.ctx are only created on x11, see
            spice_egl_init() */
 
-        if (d->egl.surface != EGL_NO_SURFACE) {
+        if (d->egl.surface != 0) {
             eglDestroySurface(d->egl.display, d->egl.surface);
-            d->egl.surface = EGL_NO_SURFACE;
+            d->egl.surface = 0;
         }
 
         if (d->egl.ctx) {
@@ -415,8 +415,8 @@
             d->egl.ctx = 0;
         }
 
-        eglMakeCurrent(d->egl.display, EGL_NO_SURFACE, EGL_NO_SURFACE,
-                       EGL_NO_CONTEXT);
+        eglMakeCurrent(d->egl.display, 0, 0,
+                       0);
 
         /* do not call eglterminate() since egl may be used by
          * somebody else code */
@@ -656,7 +656,7 @@
                   (int)(format >> 16) & 0xff, (int)format >> 24);
 
     d->egl.image = eglCreateImageKHR(d->egl.display,
-                                       EGL_NO_CONTEXT,
+                                       0,
                                        EGL_LINUX_DMA_BUF_EXT,
                                        (EGLClientBuffer)NULL,
                                        attrs);
diff -Naur spice-gtk/src/usb-acl-helper.c tainted_spice/src/usb-acl-helper.c
--- spice-gtk/src/usb-acl-helper.c	2022-07-14 09:19:52.000000000 +0200
+++ tainted_spice/src/usb-acl-helper.c	2022-07-14 09:22:54.465155083 +0200
@@ -183,7 +183,7 @@
     gsize bytes_written;
     const gchar *acl_helper = g_getenv("SPICE_USB_ACL_BINARY");
     if (acl_helper == NULL)
-        acl_helper = ACL_HELPER_PATH"/spice-client-glib-usb-acl-helper";
+        acl_helper = "/usr/local/bin/cloonix/common/spice/spice_lib/libexec/spice-client-glib-usb-acl-helper";
     gchar *argv[] = { (char*)acl_helper, NULL };
     gint in, out;
     gchar buf[128];
diff -Naur spice-gtk/tools/spice-cmdline.c tainted_spice/tools/spice-cmdline.c
--- spice-gtk/tools/spice-cmdline.c	2022-07-14 09:19:52.000000000 +0200
+++ tainted_spice/tools/spice-cmdline.c	2022-07-14 09:22:54.465155083 +0200
@@ -27,9 +27,25 @@
 static char *tls_port;
 static char *password;
 static char *uri;
+static char *cloonix_doors;
+static char *cloonix_spice;
 
 static GOptionEntry spice_entries[] = {
-    {
+   {
+        .long_name        = "cloonix-doors",
+        .short_name       = 'd',
+        .arg              = G_OPTION_ARG_STRING,
+        .arg_data         = &cloonix_doors,
+        .description      = N_("Cloon door path"),
+        .arg_description  = N_("<cloonix_doors>"),
+    },{
+        .long_name        = "cloonix-spice",
+        .short_name       = 'c',
+        .arg              = G_OPTION_ARG_STRING,
+        .arg_data         = &cloonix_spice,
+        .description      = N_("Cloon spice server path"),
+        .arg_description  = N_("<cloonix_spice>"),
+    },{
         .long_name        = "uri",
         .arg              = G_OPTION_ARG_STRING,
         .arg_data         = &uri,
@@ -85,6 +101,10 @@
 {
     g_return_if_fail(SPICE_IS_SESSION(session));
 
+    if (cloonix_doors)
+        g_object_set(session, "cloonix-doors", cloonix_doors, NULL);
+    if (cloonix_spice)
+        g_object_set(session, "cloonix-spice", cloonix_spice, NULL);
     if (uri)
         g_object_set(session, "uri", uri, NULL);
     if (host)
diff -Naur spice-gtk/tools/spicy.c tainted_spice/tools/spicy.c
--- spice-gtk/tools/spicy.c	2022-07-14 09:19:52.000000000 +0200
+++ tainted_spice/tools/spicy.c	2022-07-14 09:22:54.465155083 +0200
@@ -1268,29 +1268,29 @@
 
 static void recent_add(SpiceSession *session)
 {
-    GtkRecentManager *recent;
-    GtkRecentData meta = {
-        .mime_type    = (char*)"application/x-spice",
-        .app_name     = (char*)"spicy",
-        .app_exec     = (char*)"spicy --uri=%u",
-    };
-    char *uri;
-
-    g_object_get(session, "uri", &uri, NULL);
-    SPICE_DEBUG("%s: %s", __FUNCTION__, uri);
-
-    recent = gtk_recent_manager_get_default();
-    if (g_str_has_prefix(uri, "spice://"))
-        meta.display_name = uri + 8;
-    else if (g_str_has_prefix(uri, "spice+unix://"))
-        meta.display_name = uri + 13;
-    else
-        g_return_if_reached();
-
-    if (!gtk_recent_manager_add_full(recent, uri, &meta))
-        g_warning("Recent item couldn't be added successfully");
-
-    g_free(uri);
+//cloon suppress error
+//    GtkRecentManager *recent;
+//    GtkRecentData meta = {
+//        .mime_type    = (char*)"application/x-spice",
+//        .app_name     = (char*)"spicy",
+//        .app_exec     = (char*)"spicy --uri=%u",
+//    };
+//    char *uri;
+//
+//    g_object_get(session, "uri", &uri, NULL);
+//    SPICE_DEBUG("%s: %s", __FUNCTION__, uri);
+//
+//    recent = gtk_recent_manager_get_default();
+//
+//    if (g_str_has_prefix(uri, "spice://"))
+//        meta.display_name = uri + 8;
+//    else if (g_str_has_prefix(uri, "spice+unix://"))
+//        meta.display_name = uri + 13;
+//    else
+//        g_return_if_reached();
+//    if (!gtk_recent_manager_add_full(recent, uri, &meta))
+//        g_warning("Recent item couldn't be added successfully");
+//    g_free(uri);
 }
 
 static void main_channel_event(SpiceChannel *channel, SpiceChannelEvent event,
@@ -1303,7 +1303,7 @@
 
     switch (event) {
     case SPICE_CHANNEL_OPENED:
-        g_message("main channel: opened");
+//        g_message("main channel: opened");
         recent_add(conn->session);
         break;
     case SPICE_CHANNEL_SWITCHING:
@@ -1311,7 +1311,7 @@
         break;
     case SPICE_CHANNEL_CLOSED:
         /* this event is only sent if the channel was succesfully opened before */
-        g_message("main channel: closed");
+//        g_message("main channel: closed");
         connection_disconnect(conn);
         break;
     case SPICE_CHANNEL_ERROR_IO:
@@ -2003,7 +2003,6 @@
     GOptionContext *context;
     spice_connection *conn;
     gchar *conf_file, *conf;
-    char *host = NULL, *port = NULL, *tls_port = NULL, *unix_path = NULL;
 
     keyfile = g_key_file_new();
 
@@ -2047,23 +2046,6 @@
     spice_set_session_option(conn->session);
     spice_cmdline_session_setup(conn->session);
 
-    g_object_get(conn->session,
-                 "unix-path", &unix_path,
-                 "host", &host,
-                 "port", &port,
-                 "tls-port", &tls_port,
-                 NULL);
-    /* If user doesn't provide hostname and port, show the dialog window
-       instead of connecting to server automatically */
-    if ((host == NULL || (port == NULL && tls_port == NULL)) && unix_path == NULL) {
-        if (!spicy_connect_dialog(conn->session)) {
-            exit(0);
-        }
-    }
-    g_free(host);
-    g_free(port);
-    g_free(tls_port);
-    g_free(unix_path);
 
     connection_connect(conn);
     if (connections > 0)
