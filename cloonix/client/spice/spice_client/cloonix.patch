diff -Naur spice-gtk/configure tainted_spice/configure
--- spice-gtk/configure	2019-02-24 09:33:23.000000000 +0100
+++ tainted_spice/configure	2019-02-24 09:33:48.131773632 +0100
@@ -20187,6 +20187,7 @@
 else
   enable_vala="no"
 fi
+  enable_vala="no"
 
 
 VALA_REQUIRED=0.14
diff -Naur spice-gtk/src/cloonix.c tainted_spice/src/cloonix.c
--- spice-gtk/src/cloonix.c	1970-01-01 01:00:00.000000000 +0100
+++ tainted_spice/src/cloonix.c	2019-02-24 09:33:48.131773632 +0100
@@ -0,0 +1,613 @@
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <syslog.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <sys/stat.h>
+
+#include <errno.h>
+
+#include <glib-object.h>
+#include <gio/gio.h>
+
+#include "cloonix.h"
+#include "hmac_cipher.h"
+
+
+typedef struct t_rx_pktbuf
+{
+  char buf[MAX_DOORWAYS_BUF_LEN];
+  int  offset;
+  int  idx_hmac;
+  int  dido_llid;
+  int  size_req;
+  int  paylen;
+  int  paylen_given;
+  int  type;
+  int  val;
+  int  nb_pkt_rx;
+  char *payload;
+} t_rx_pktbuf;
+
+
+
+typedef struct t_sock_ctx
+{
+  GSocket *gsock;
+  int sock;
+  int nb_tx_pkt;
+  t_rx_pktbuf rx_pktbuf;
+} t_sock_ctx;
+
+static t_sock_ctx *g_sock_ctx[MAX_FD_NUMBER_CTX];
+
+
+long long cloonix_get_msec(void);
+/*****************************************************************************/
+long long cloonix_get_msec(void)
+{
+  return 0;
+}
+/*---------------------------------------------------------------------------*/
+
+/*****************************************************************************/
+static int test_file_is_socket(char *path)
+{
+  int result = -1;
+  struct stat stat_file;
+  if (!stat(path, &stat_file))
+    {
+    if (S_ISSOCK(stat_file.st_mode))
+      result = 0;
+    }
+  return result;
+}
+/*---------------------------------------------------------------------------*/
+
+/****************************************************************************/
+static int tst_port(char *str_port, int *port)
+{
+  int result = 0;
+  unsigned long val;
+  char *endptr;
+  val = strtoul(str_port, &endptr, 10);
+  if ((endptr == NULL)||(endptr[0] != 0))
+    result = -1;
+  else
+    {
+    if ((val < 1) || (val > 65535))
+      result = -1;
+    *port = (int) val;
+    }
+  return result;
+}
+/*--------------------------------------------------------------------------*/
+
+/*****************************************************************************/
+int get_address_from_param(char *param, char *ip, int *port)
+{
+  char pm[300];
+  int result = 0;
+  char *ptr_ip, *ptr_port;
+  if (strlen(param) >= 300)
+    KOUT("param LENGTH Problem");
+  else
+    {
+    memset(pm, 0, 300);
+    strncpy(pm, param, 300-1);
+    memset(ip, 0, 100);
+    ptr_ip = pm;
+    ptr_port = strchr(pm, ':');
+    if (ptr_port)
+      {
+      result = 1;
+      *ptr_port = 0;
+      ptr_port++;
+      strncpy(ip, ptr_ip, 99);
+      if (tst_port(ptr_port, port))
+        KOUT("PORT param Problem %s", param);
+      }
+    else
+      {
+      if (test_file_is_socket(param))
+        KOUT("Not unix: %s", param);
+      }
+    }
+  return result;
+}
+/*---------------------------------------------------------------------------*/
+
+/****************************************************************************/
+static void alloc_sock_ctx(GSocket *gsock, int sock)
+{
+  int fd_sock = g_socket_get_fd(gsock);
+  if (sock != fd_sock)
+    KOUT("%d %d", sock, fd_sock);
+  if (g_sock_ctx[sock])
+    KOUT(" ");
+  g_sock_ctx[sock] = (t_sock_ctx *) malloc(sizeof(t_sock_ctx));
+  memset(g_sock_ctx[sock], 0, sizeof(t_sock_ctx));
+  g_sock_ctx[sock]->gsock = gsock;
+  g_sock_ctx[sock]->sock = sock;
+  g_sock_ctx[sock]->nb_tx_pkt = 1;
+  g_sock_ctx[sock]->rx_pktbuf.nb_pkt_rx = 1;
+}
+/*--------------------------------------------------------------------------*/
+
+/****************************************************************************/
+static t_sock_ctx *get_sock_ctx(int sock)
+{
+  return g_sock_ctx[sock];
+}
+/*--------------------------------------------------------------------------*/
+
+
+/****************************************************************************/
+static void set_hmac_password(int i, char *tx, int len, char *payload)
+{
+  int j, idx = i;
+  char *md = compute_msg_digest(len, payload);
+  for (j=0; j<MSG_DIGEST_LEN; j++)
+    tx[idx++] = md[j];
+}
+/*--------------------------------------------------------------------------*/
+
+/****************************************************************************/
+static int check_hmac_password(int i, char *rx, int len, char *payload)
+{
+  int j, k, idx, result = 0;
+  char *md = compute_msg_digest(len, payload);
+  idx = i;
+  for (j=0; j<MSG_DIGEST_LEN; j++)
+    {
+    k = idx++;
+    if (rx[k] != md[j])
+      {
+      result = -1;
+      break;
+      }
+    }
+  return result;
+}
+/*--------------------------------------------------------------------------*/
+
+
+/****************************************************************************/
+static void sock_header_set_info(char *tx,
+                                 int llid, int len, int type, int val,
+                                 int nb_pkt, char **ntx)
+{
+  int idx_hmac, i = 0;
+
+  tx[i++] = 0xCA & 0xFF;
+  tx[i++] = 0xFE & 0xFF;
+
+  tx[i++] = ((llid & 0xFF00) >> 8) & 0xFF;
+  tx[i++] = llid & 0xFF;
+  tx[i++] = ((len & 0xFF000000) >> 24) & 0xFF;
+  tx[i++] = ((len & 0xFF0000) >> 16) & 0xFF;
+  tx[i++] = ((len & 0xFF00) >> 8) & 0xFF;
+  tx[i++] = len & 0xFF;
+  tx[i++] = ((type & 0xFF00) >> 8) & 0xFF;
+  tx[i++] = type & 0xFF;
+  tx[i++] = ((val & 0xFF00) >> 8) & 0xFF;
+  tx[i++] = val & 0xFF;
+  tx[i++] = ((nb_pkt & 0xFF00) >> 8) & 0xFF;
+  tx[i++] = nb_pkt & 0xFF;
+  idx_hmac = i;
+  i += MSG_DIGEST_LEN;
+  tx[i++] = 0xDE & 0xFF;
+  tx[i++] = 0xCA & 0xFF;
+
+  *ntx = &(tx[i++]);
+  set_hmac_password(idx_hmac, tx, len, *ntx);
+}
+/*--------------------------------------------------------------------------*/
+
+
+/****************************************************************************/
+static int sock_header_get_info(char *rx,
+                                 int *llid, int *len, int *type, int *val,
+                                 int *nb_pkt, char **nrx)
+{
+  int idx_hmac, i = 0, result=0;
+  if ((rx[i++] & 0xFF) != 0xCA)
+    {
+    for (i=0; i<16; i++)
+      printf(" %02X", (unsigned int)(rx[i] & 0xFF));
+    KERR("%02X \n", (unsigned int)(rx[0] & 0xFF));
+    result = -1;
+    }
+  else if ((rx[i++] & 0xFF) != 0xFE)
+    {
+    KERR("%02X \n", (unsigned int) (rx[1]));
+    result = -1;
+    }
+  else
+    {
+    *llid = ((rx[i] & 0xFF) << 8) + (rx[i+1] & 0xFF);
+    i += 2; 
+    *len  = ((rx[i] & 0xFF) << 24) + ((rx[i+1] & 0xFF) << 16);
+    i += 2;
+    *len  += ((rx[i] & 0xFF) << 8) + (rx[i+1] & 0xFF);
+    i += 2; 
+    *type = ((rx[i] & 0xFF) << 8) + (rx[i+1] & 0xFF);
+    i += 2; 
+    *val  = ((rx[i] & 0xFF) << 8) + (rx[i+1] & 0xFF);
+    i += 2;  
+    *nb_pkt  = ((rx[i] & 0xFF) << 8) + (rx[i+1] & 0xFF);
+    i += 2;
+    idx_hmac = i;
+    i += MSG_DIGEST_LEN; 
+    if ((rx[i++] & 0xFF) != 0xDE)
+      {
+      KERR("%02X \n", (unsigned int) (rx[i-1]));
+      result = -1;
+      }
+    else if ((rx[i++] & 0xFF) != 0xCA)
+      {
+      KERR("%02X \n", (unsigned int) (rx[i-1]));
+      result = -1;
+      }
+    else
+      {
+      result = idx_hmac;
+      *nrx  = &(rx[i++]);
+      }
+    }
+  return result;
+}
+/*--------------------------------------------------------------------------*/
+
+/****************************************************************************/
+static int check_extract_rx(char *rx, int expect_val, int expect_pkt, 
+                            int *len, char **payload) 
+{
+  int idx_hmac, type, llid, val, pkt, result = -1;
+  idx_hmac = sock_header_get_info(rx, &llid, len, &type, &val, &pkt, payload);
+  if (idx_hmac != -1)
+    {
+    if (type != doors_type_spice)
+      KERR("%d", type);
+    else if (val != expect_val)
+      KERR("%d %d", val, expect_val);
+    else if (pkt != expect_pkt)
+      {
+      result = 0;
+      KERR("%d %d", pkt, expect_pkt);
+      }
+    else if (idx_hmac != 14)
+      KOUT("%d", idx_hmac); 
+    else
+      result = 0;
+    }
+  return result;
+}
+/*--------------------------------------------------------------------------*/
+
+/****************************************************************************/
+static int rx_first_msg(int sock, int *dlen, char **drx)
+{
+  char rx[DOORWAYS_HEADER_SIZE + 3];
+  int len, result = -1;
+  fd_set infd;
+  FD_ZERO(&infd);
+  FD_SET(sock, &infd);
+  result = select(sock + 1, &infd, NULL, NULL, NULL);
+  if ( result < 0 )
+    KOUT(" ");
+  else if (FD_ISSET(sock, &infd))
+    {
+    len = read(sock, rx, DOORWAYS_HEADER_SIZE + 3);
+    if (len != DOORWAYS_HEADER_SIZE + 3)
+      KERR("%d %d", len, DOORWAYS_HEADER_SIZE + 3);
+    else
+      {
+      result = check_extract_rx(rx, doors_val_link_ok, 1, dlen, drx);
+      if (result)
+        KOUT(" ");
+      result = check_hmac_password(14, rx, *dlen, *drx);
+      if (result)
+        KOUT("BAD PASSWORD");
+      }
+    }
+  else
+    KOUT(" ");
+  return result;
+}
+/*--------------------------------------------------------------------------*/
+
+/****************************************************************************/
+static int tx_header(int val, int len, char *buf, int nb_pkt_tx)
+{
+  char *payload;
+  int tot_len = len + DOORWAYS_HEADER_SIZE;
+  sock_header_set_info(buf, 0, len, 
+                       doors_type_spice, val,
+                       nb_pkt_tx, &payload);
+  if (payload != buf + DOORWAYS_HEADER_SIZE)
+    KOUT("%p %p", payload, buf);
+  return tot_len;
+}
+/*---------------------------------------------------------------------------*/
+
+/****************************************************************************/
+static int rx_pktbuf_fill(t_sock_ctx *ctx, t_rx_pktbuf *rx_pktbuf, 
+                          GError **error)
+{
+  int headsize = DOORWAYS_HEADER_SIZE;
+  int result, len_desired, len_avail;
+  if (rx_pktbuf->offset < headsize)
+    {
+    if (rx_pktbuf->paylen != 0)
+      KOUT(" ");
+    if (rx_pktbuf->payload)
+      KOUT(" ");
+    len_desired = headsize - rx_pktbuf->offset;
+    result = 1;
+    }
+  else
+    {
+    if (rx_pktbuf->paylen <= 0)
+      KOUT(" ");
+    if (!rx_pktbuf->payload)
+      KOUT(" ");
+    len_desired = headsize + rx_pktbuf->paylen - rx_pktbuf->offset;
+    if (len_desired > rx_pktbuf->size_req)
+      len_desired = rx_pktbuf->size_req;
+    result = 3;
+    }
+  if (len_desired + rx_pktbuf->offset > MAX_DOORWAYS_BUF_LEN)
+    KOUT("%d %d", len_desired, rx_pktbuf->offset);
+  len_avail = g_socket_receive(ctx->gsock, 
+                               rx_pktbuf->buf + rx_pktbuf->offset, 
+                               len_desired, NULL, error);
+  if (len_avail > 0)
+    {
+    rx_pktbuf->offset += len_avail;
+    if ((result == 1) && (len_desired != len_avail))
+      result = 2; 
+    if ((result == 3) && (len_avail > 0))
+      result = 5; 
+    }
+  else
+    result = -1;
+  return result;
+}
+/*--------------------------------------------------------------------------*/
+
+/****************************************************************************/
+static int rx_pktbuf_get_paylen(t_rx_pktbuf *rx_pktbuf)
+{
+  int nb_pkt, result = 0;
+  rx_pktbuf->idx_hmac = sock_header_get_info(rx_pktbuf->buf,
+                                             &(rx_pktbuf->dido_llid),
+                                             &(rx_pktbuf->paylen),
+                                             &(rx_pktbuf->type),
+                                             &(rx_pktbuf->val),
+                                             &(nb_pkt),
+                                             &(rx_pktbuf->payload));
+  if (rx_pktbuf->idx_hmac == -1)
+    {
+    KOUT(" ");
+    result = -1;
+    rx_pktbuf->offset = 0;
+    rx_pktbuf->paylen = 0;
+    rx_pktbuf->payload = NULL;
+    rx_pktbuf->dido_llid = 0;
+    rx_pktbuf->type = 0;
+    rx_pktbuf->val = 0;
+    }
+  else
+    {
+    if ((nb_pkt-1) != rx_pktbuf->nb_pkt_rx)
+      {
+      KERR("%d %d", nb_pkt, rx_pktbuf->nb_pkt_rx);
+      result = -1;
+      }
+    if (nb_pkt == 0xFFFF)
+      rx_pktbuf->nb_pkt_rx = 0;
+    else
+      rx_pktbuf->nb_pkt_rx = nb_pkt;
+    }
+  return result;
+}
+/*--------------------------------------------------------------------------*/
+
+/****************************************************************************/
+static int rx_doorways(t_sock_ctx *ctx, t_rx_pktbuf *rx_pktbuf, GError **error)
+{
+  int res;
+  int headsize = DOORWAYS_HEADER_SIZE;
+
+  if ((rx_pktbuf->paylen > 0) && 
+      (rx_pktbuf->offset == rx_pktbuf->paylen + headsize) &&
+      (rx_pktbuf->paylen_given < rx_pktbuf->paylen)) 
+    {
+    res = 5;
+    }
+  else
+    {
+    res = rx_pktbuf_fill(ctx, rx_pktbuf, error);
+    if (res == 1)
+      {
+      rx_pktbuf_get_paylen(rx_pktbuf);
+      res = rx_pktbuf_fill(ctx, rx_pktbuf, error);
+      }
+    }
+
+  if (res == 5)
+    {
+    if (!rx_pktbuf->payload)
+      KOUT(" ");
+    if (rx_pktbuf->paylen <= 0)
+      KOUT(" ");
+    if (rx_pktbuf->idx_hmac != 14)
+      KOUT("%d", rx_pktbuf->idx_hmac);
+    if (rx_pktbuf->type != doors_type_spice)
+      KOUT("%d %d", rx_pktbuf->type, doors_type_spice);
+    if (rx_pktbuf->val != doors_val_none)
+      KOUT("%d %d", rx_pktbuf->val, doors_val_none);
+    if (rx_pktbuf->offset == rx_pktbuf->paylen + headsize)
+      {
+      if (check_hmac_password(rx_pktbuf->idx_hmac, rx_pktbuf->buf,
+                            rx_pktbuf->paylen, rx_pktbuf->payload))
+        KOUT("BAD PASSWORD: %d %d %d", rx_pktbuf->paylen, 
+                                       rx_pktbuf->offset, 
+                                       rx_pktbuf->paylen_given);
+      }
+    }
+  return res;
+}
+/*--------------------------------------------------------------------------*/
+
+/****************************************************************************/
+static int tx_doorways(t_sock_ctx *ctx, int len, char *buf, GError **error)
+{
+  int ret, tot_len, result = 0;
+  char *msg_buf;
+  int max = MAX_DOORWAYS_BUF_LEN - DOORWAYS_HEADER_SIZE;
+  if ((len<0) || (len >= max))
+    KOUT("%d %d", len, max);
+  if (len > 0)
+    {
+    if (ctx->nb_tx_pkt == 0xFFFF)
+      ctx->nb_tx_pkt = 1;
+    else
+      ctx->nb_tx_pkt += 1;
+    msg_buf = (char *) malloc(len + DOORWAYS_HEADER_SIZE);
+    memcpy(msg_buf + DOORWAYS_HEADER_SIZE, buf, len);
+    tot_len = tx_header(doors_val_none, len, msg_buf, ctx->nb_tx_pkt);
+    ret = g_socket_send(ctx->gsock, msg_buf, tot_len, NULL, error);
+    if (ret <= 0)
+      result = ret;
+    else if (ret != tot_len)
+      KOUT("%d %d", ret, tot_len);
+    else 
+      result = len; 
+    free(msg_buf);
+    }
+  return result;
+}
+/*---------------------------------------------------------------------------*/
+
+/****************************************************************************/
+void cloonix_preliminaries(char *password, GSocket *gsock, int sock, char *spice_sock) 
+{
+  char buf[300+DOORWAYS_HEADER_SIZE];
+  int headsize = DOORWAYS_HEADER_SIZE;
+  int len = strlen(spice_sock) + 1;
+  int tot_len, tx_len, dlen;
+  char *drx;
+  if (!password)
+    KOUT(" ");
+  if (strlen(password) < 2)
+    KOUT("%d %s", (int) strlen(password), password);
+  if (strlen(password) >= MSG_DIGEST_LEN)
+    KOUT("%d %s", (int) strlen(password), password);
+  cipher_myinit(password);
+  if (sock >= MAX_FD_NUMBER_CTX)
+    KOUT("%d %d", sock, MAX_FD_NUMBER_CTX);
+  memset(buf, 0, 300);
+  strncpy(buf+headsize, spice_sock, 300-1); 
+  tot_len = tx_header(doors_val_init_link, len, buf, 1);
+  tx_len = write(sock, buf, tot_len); 
+  if (tx_len != tot_len)
+    KERR("ERR tx : %d %d", tx_len, tot_len);
+  if (!rx_first_msg(sock, &dlen, &drx))
+    {
+    alloc_sock_ctx(gsock, sock);
+    }
+  else
+    KERR("ERROR %s", drx);
+}
+
+
+
+/****************************************************************************/
+gssize cloonix_g_socket_send (GSocket *socket, const gchar *buffer, 
+                              gsize size, GCancellable *cancellable, 
+                              GError **error)
+{
+  gssize ret;
+  int fd_sock;
+  t_sock_ctx *ctx;
+  fd_sock = g_socket_get_fd(socket);
+  ctx = get_sock_ctx(fd_sock);
+  if (!ctx)
+    KOUT(" ");
+  ret = tx_doorways(ctx, (int) size, (char *) buffer, error);
+  return ret;
+}
+/*--------------------------------------------------------------------------*/
+
+
+/****************************************************************************/
+gssize cloonix_g_socket_receive(GSocket *socket, gchar *buffer, gsize size,
+                                GCancellable *cancellable, GError **error)
+{
+  int headsize = DOORWAYS_HEADER_SIZE;
+  int fd_sock, result, len_to_give, left_to_give;
+  t_sock_ctx *ctx;
+  t_rx_pktbuf *rx_pktbuf;
+  fd_sock = g_socket_get_fd(socket);
+  ctx = get_sock_ctx(fd_sock);
+  if (!ctx)
+    KOUT(" ");
+  if (socket != ctx->gsock)
+    KOUT(" ");
+  rx_pktbuf = &(ctx->rx_pktbuf);
+  rx_pktbuf->size_req = size;
+  result = rx_doorways(ctx, rx_pktbuf, error);
+  if (result == 2)
+    {
+    result = -1;
+    g_set_error (error, G_IO_ERROR, G_IO_ERROR_WOULD_BLOCK, "fd would block");
+    }
+  else if (result != -1)
+    { 
+    if (result != 5)
+      KERR("%d %d %d %d", result, rx_pktbuf->paylen, rx_pktbuf->offset, 
+                          rx_pktbuf->paylen_given);
+    else
+      {
+      left_to_give = rx_pktbuf->offset - headsize - rx_pktbuf->paylen_given; 
+      if (left_to_give < 0) 
+        KOUT("%d", left_to_give);
+      if (size < left_to_give)
+        len_to_give = size;
+      else
+        len_to_give = left_to_give;
+      result = len_to_give;
+      if (result == 0)
+        {
+        result = -1;
+        g_set_error (error, G_IO_ERROR, G_IO_ERROR_WOULD_BLOCK, "fd would block");
+        KERR("%d %d %d", rx_pktbuf->paylen, rx_pktbuf->offset, 
+                         rx_pktbuf->paylen_given);
+        }
+      else
+        {
+        memcpy(buffer, rx_pktbuf->payload + rx_pktbuf->paylen_given, len_to_give);
+        rx_pktbuf->paylen_given += len_to_give;
+        if (rx_pktbuf->paylen_given == rx_pktbuf->paylen)
+          {
+          rx_pktbuf->offset = 0;
+          rx_pktbuf->paylen = 0;
+          rx_pktbuf->paylen_given = 0;
+          rx_pktbuf->payload = NULL;
+          rx_pktbuf->dido_llid = 0;
+          rx_pktbuf->type = 0;
+          rx_pktbuf->val = 0;
+          }
+        }
+      }
+    }
+  return result;
+}
+/*--------------------------------------------------------------------------*/
+
+
+
diff -Naur spice-gtk/src/cloonix.h tainted_spice/src/cloonix.h
--- spice-gtk/src/cloonix.h	1970-01-01 01:00:00.000000000 +0100
+++ tainted_spice/src/cloonix.h	2019-02-24 09:33:48.131773632 +0100
@@ -0,0 +1,22 @@
+
+
+#include <syslog.h>
+#include "../../../glob_include/glob_common.h"
+
+
+#define MAX_FD_NUMBER_CTX  100
+
+
+/*--------------------------------------------------------------------------*/
+void cloonix_preliminaries(char *password, GSocket *gsock, int sock, char *spice_sock);
+/*--------------------------------------------------------------------------*/
+gssize cloonix_g_socket_send (GSocket *socket, const gchar *buffer,
+                              gsize size, GCancellable *cancellable,
+                              GError **error);
+/*--------------------------------------------------------------------------*/
+gssize cloonix_g_socket_receive(GSocket *socket, gchar *buffer, gsize size,
+                                GCancellable *cancellable, GError **error);
+/*--------------------------------------------------------------------------*/
+int get_address_from_param(char *param, char *ip, int *port);
+/*--------------------------------------------------------------------------*/
+
diff -Naur spice-gtk/src/hmac_cipher.c tainted_spice/src/hmac_cipher.c
--- spice-gtk/src/hmac_cipher.c	1970-01-01 01:00:00.000000000 +0100
+++ tainted_spice/src/hmac_cipher.c	2019-02-24 09:33:48.131773632 +0100
@@ -0,0 +1,146 @@
+/****************************************************************************/
+/* Copyright (C) 2006-2014 Cloonix <clownix@clownix.net>  License RPL       */
+/****************************************************************************/
+/*                                                                          */
+/* Unless explicitly acquired and licensed from Licensor under another      */
+/* license, the contents of this file are subject to the Reciprocal Public  */
+/* License ("RPL") Version 1.5, or subsequent versions as allowed by the    */
+/* RPL, and You may not copy or use this file in either source code or      */
+/* executable form, except in compliance with the terms and conditions of   */
+/* the RPL.                                                                 */
+/*                                                                          */
+/* All software distributed under the RPL is provided strictly on an "AS    */
+/* IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, AND  */
+/* LICENSOR HEREBY DISCLAIMS ALL SUCH WARRANTIES, INCLUDING WITHOUT         */
+/* LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR  */
+/* PURPOSE, QUIET ENJOYMENT, OR NON-INFRINGEMENT. See the RPL for specific  */
+/* language governing rights and limitations under the RPL.                 */
+/*                                                                          */
+/****************************************************************************/
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <errno.h>
+
+#include <openssl/hmac.h>
+#include <openssl/evp.h>
+#include "hmac_cipher.h"
+
+#include <syslog.h>
+#define KOUT(format, a...)                               \
+ do {                                                    \
+    printf("\n%s %s line:%d   " format,         \
+    __FILE__,__FUNCTION__,__LINE__, ## a);               \
+    syslog(LOG_ERR, "%s %s line:%d   " format, \
+    __FILE__,__FUNCTION__,__LINE__, ## a);               \
+    exit(-1);                                            \
+    } while (0)
+
+static unsigned char glob_key[MSG_DIGEST_LEN];
+static const EVP_MD *md_hmac_sha;
+static EVP_CIPHER_CTX *cipher_ctx;
+
+/*****************************************************************************/
+char *compute_msg_digest(int len, char *data)
+{
+  unsigned char *md;
+  unsigned int md_len;
+  md = HMAC(md_hmac_sha, ( unsigned char *)glob_key, MSG_DIGEST_LEN, 
+            (const unsigned char *) data, (unsigned int) len, NULL, &md_len);
+  if (md_len != MSG_DIGEST_LEN)
+    KOUT("%d %d", (int) md_len, (int) MSG_DIGEST_LEN);
+  return (char *)md;
+}
+/*---------------------------------------------------------------------------*/
+
+/*****************************************************************************/
+static int cipher( int do_encrypt, unsigned char *iv, 
+            int inlen, unsigned char *inbuf,
+            unsigned char *outbuf)
+{
+  int len, tot_len = 0;
+  EVP_CIPHER_CTX_init(cipher_ctx);
+  EVP_CipherInit_ex(cipher_ctx, EVP_aes_256_cbc(), NULL, 
+                    glob_key, iv, do_encrypt);
+  EVP_CIPHER_CTX_set_key_length(cipher_ctx, MSG_DIGEST_LEN);
+  if (EVP_CipherUpdate(cipher_ctx, outbuf, &len, inbuf, inlen))
+    {
+    tot_len += len;
+    if (EVP_CipherFinal_ex(cipher_ctx, outbuf+tot_len, &len))
+      tot_len += len;
+    }
+  EVP_CIPHER_CTX_cleanup(cipher_ctx);
+  return tot_len;
+}
+/*---------------------------------------------------------------------------*/
+
+/*****************************************************************************/
+int hmac_extract_and_decipher(int len, char *buf, char **outbuf)
+{
+  int outlen = 0;
+  char *md = buf;
+  char *md_check;
+  *outbuf = NULL;
+  if (len > MSG_DIGEST_LEN)
+    {
+    *outbuf = (char *) malloc(len);
+    outlen = cipher( 0, (unsigned char *) md, len-MSG_DIGEST_LEN, 
+    (unsigned char *) (buf+MSG_DIGEST_LEN), (unsigned char *) (*outbuf));   
+    if (!outlen)
+      {
+      free(*outbuf);
+      *outbuf = NULL;
+      }
+    else
+      {
+      md_check = compute_msg_digest(outlen, *outbuf);
+      if (memcmp(md_check, md, MSG_DIGEST_LEN))
+        {
+        free(*outbuf);
+        *outbuf = NULL;
+        outlen = 0;
+        }
+      }
+    }
+  return outlen;
+}
+/*---------------------------------------------------------------------------*/
+
+/*****************************************************************************/
+int hmac_insert_and_cipher(int len, char *buf, char **outbuf)
+{
+  int outlen, max_len;
+  char *md = compute_msg_digest(len, buf);
+  max_len = len + 2*MSG_DIGEST_LEN;
+  *outbuf = (char *) malloc(max_len);
+  memcpy(*outbuf, md, MSG_DIGEST_LEN);
+  outlen = cipher( 1, (unsigned char *) md, len, 
+           (unsigned char *) buf, (unsigned char *) (*outbuf+MSG_DIGEST_LEN)); 
+  if (!outlen)
+    {
+    free(*outbuf);
+    *outbuf = NULL;
+    }
+  else
+    outlen += MSG_DIGEST_LEN;
+  return outlen;
+}
+/*---------------------------------------------------------------------------*/
+
+/*****************************************************************************/
+void cipher_myinit(char *key)
+{
+  cipher_ctx = EVP_CIPHER_CTX_new();
+  if ((strlen(key) < 2) || (strlen(key) >= MSG_DIGEST_LEN))
+    KOUT("%d %s", (int) (strlen(key)), key);
+  memset(glob_key, 0, MSG_DIGEST_LEN);
+  memcpy(glob_key, key, strlen(key));
+  OpenSSL_add_all_digests();
+  md_hmac_sha = EVP_get_digestbyname("SHA256");
+  if(!md_hmac_sha)
+    KOUT("Unknown message digest \"SHA256\"");
+}
+/*---------------------------------------------------------------------------*/
+
+
diff -Naur spice-gtk/src/hmac_cipher.h tainted_spice/src/hmac_cipher.h
--- spice-gtk/src/hmac_cipher.h	1970-01-01 01:00:00.000000000 +0100
+++ tainted_spice/src/hmac_cipher.h	2019-02-24 09:33:48.131773632 +0100
@@ -0,0 +1,28 @@
+/*****************************************************************************/
+/*    Copyright (C)  2006-2012    Cloonix,    <clownix@clownix.net>          */
+/*****************************************************************************/
+/*                                                                           */
+/*    This program is free software: you can redistribute it and/or modify   */
+/*    it under the terms of the GNU General Public License as published by   */
+/*    the Free Software Foundation, either version 3 of the License, or      */
+/*    (at your option) any later version.                                    */
+/*                                                                           */
+/*    This program is distributed in the hope that it will be useful,        */
+/*    but WITHOUT ANY WARRANTY; without even the implied warranty of         */
+/*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          */
+/*    GNU General Public License for more details.                           */
+/*                                                                           */
+/*    You should have received a copy of the GNU General Public License      */
+/*    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+/*                                                                           */
+/*****************************************************************************/
+#define MSG_DIGEST_LEN 32
+#define DOORWAYS_HEADER_SIZE (16+MSG_DIGEST_LEN)
+char *compute_msg_digest(int len, char *data);
+int hmac_extract_and_decipher(int len, char *buf, char **outbuf);
+int hmac_insert_and_cipher(int len, char *buf, char **outbuf);
+void cipher_myinit(char *key);
+/*---------------------------------------------------------------------------*/
+
+
+
diff -Naur spice-gtk/src/Makefile.am tainted_spice/src/Makefile.am
--- spice-gtk/src/Makefile.am	2019-02-24 09:33:02.000000000 +0100
+++ tainted_spice/src/Makefile.am	2019-02-24 09:33:48.131773632 +0100
@@ -229,6 +229,8 @@
 							\
 	spice-client.c					\
 	spice-session.c					\
+	cloonix.c					\
+        hmac_cipher.c                                   \
 	spice-session-priv.h				\
 	spice-channel.c					\
 	spice-channel-cache.h				\
@@ -513,6 +515,8 @@
 	spice-audio.c					\
 	spice-client.c					\
 	spice-session.c					\
+	cloonix.c					\
+        hmac_cipher.c                                   \
 	spice-channel.c					\
 	spice-glib-enums.c				\
 	spice-option.c					\
diff -Naur spice-gtk/src/Makefile.in tainted_spice/src/Makefile.in
--- spice-gtk/src/Makefile.in	2019-02-24 09:33:25.000000000 +0100
+++ tainted_spice/src/Makefile.in	2019-02-24 09:33:48.131773632 +0100
@@ -217,6 +217,7 @@
 	spice-gstaudio.h spice-common.h spice-util.c spice-util-priv.h \
 	spice-option.h spice-option.c spice-client.c spice-session.c \
 	spice-session-priv.h spice-channel.c spice-channel-cache.h \
+        cloonix.c cloonix.h hmac_cipher.c hmac_cipher.h \
 	spice-channel-priv.h spice-file-transfer-task.c \
 	spice-file-transfer-task-priv.h coroutine.h gio-coroutine.c \
 	gio-coroutine.h channel-base.c channel-webdav.c \
@@ -253,6 +254,7 @@
 	spice-file-transfer-task.lo gio-coroutine.lo channel-base.lo \
 	channel-webdav.lo channel-cursor.lo channel-display.lo \
 	channel-display-gst.lo channel-inputs.lo channel-main.lo \
+        cloonix.lo hmac_cipher.lo \
 	channel-playback.lo channel-port.lo channel-record.lo \
 	channel-smartcard.lo channel-usbredir.lo qmp-port.lo \
 	smartcard-manager.lo spice-uri.lo usb-device-manager.lo \
@@ -342,6 +344,7 @@
 	./$(DEPDIR)/gio-coroutine.Plo ./$(DEPDIR)/giopipe.Plo \
 	./$(DEPDIR)/qmp-port.Plo ./$(DEPDIR)/smartcard-manager.Plo \
 	./$(DEPDIR)/spice-audio.Plo ./$(DEPDIR)/spice-channel.Plo \
+	./$(DEPDIR)/cloonix.Plo ./$(DEPDIR)/hmac_cipher.Plo \
 	./$(DEPDIR)/spice-client.Plo \
 	./$(DEPDIR)/spice-file-transfer-task.Plo \
 	./$(DEPDIR)/spice-glib-enums.Plo \
@@ -854,6 +857,7 @@
 	spice-gstaudio.h spice-common.h spice-util.c spice-util-priv.h \
 	spice-option.h spice-option.c spice-client.c spice-session.c \
 	spice-session-priv.h spice-channel.c spice-channel-cache.h \
+        cloonix.c cloonix.h hmac_cipher.c hmac_cipher.h \
 	spice-channel-priv.h spice-file-transfer-task.c \
 	spice-file-transfer-task-priv.h coroutine.h gio-coroutine.c \
 	gio-coroutine.h channel-base.c channel-webdav.c \
@@ -945,6 +949,8 @@
 @HAVE_INTROSPECTION_TRUE@	spice-audio.c					\
 @HAVE_INTROSPECTION_TRUE@	spice-client.c					\
 @HAVE_INTROSPECTION_TRUE@	spice-session.c					\
+@HAVE_INTROSPECTION_TRUE@	cloonix.c					\
+@HAVE_INTROSPECTION_TRUE@	hmac_cipher.c					\
 @HAVE_INTROSPECTION_TRUE@	spice-channel.c					\
 @HAVE_INTROSPECTION_TRUE@	spice-glib-enums.c				\
 @HAVE_INTROSPECTION_TRUE@	spice-option.c					\
@@ -1169,6 +1175,8 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/smartcard-manager.Plo@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/spice-audio.Plo@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/spice-channel.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cloonix.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/hmac_cipher.Plo@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/spice-client.Plo@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/spice-file-transfer-task.Plo@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/spice-glib-enums.Plo@am__quote@ # am--include-marker
@@ -1605,6 +1613,8 @@
 	-rm -f ./$(DEPDIR)/smartcard-manager.Plo
 	-rm -f ./$(DEPDIR)/spice-audio.Plo
 	-rm -f ./$(DEPDIR)/spice-channel.Plo
+	-rm -f ./$(DEPDIR)/cloonix.Plo
+	-rm -f ./$(DEPDIR)/hmac_cipher.Plo
 	-rm -f ./$(DEPDIR)/spice-client.Plo
 	-rm -f ./$(DEPDIR)/spice-file-transfer-task.Plo
 	-rm -f ./$(DEPDIR)/spice-glib-enums.Plo
diff -Naur spice-gtk/src/spice-channel.c tainted_spice/src/spice-channel.c
--- spice-gtk/src/spice-channel.c	2019-02-24 09:33:02.000000000 +0100
+++ tainted_spice/src/spice-channel.c	2019-02-24 09:33:48.131773632 +0100
@@ -47,6 +47,11 @@
 
 #include "gio-coroutine.h"
 
+/*CLOONIX*/
+#include "cloonix.h"
+/*CLOONIX*/
+
+
 static void spice_channel_handle_msg(SpiceChannel *channel, SpiceMsgIn *msg);
 static void spice_channel_write_msg(SpiceChannel *channel, SpiceMsgOut *out);
 static void spice_channel_send_link(SpiceChannel *channel);
@@ -792,8 +797,9 @@
         }
     } else {
         GError *error = NULL;
-        ret = g_pollable_output_stream_write_nonblocking(G_POLLABLE_OUTPUT_STREAM(c->out),
-                                                         ptr, len, NULL, &error);
+
+        ret = cloonix_g_socket_send(c->sock, ptr, len, NULL, &error);
+
         if (ret < 0) {
             if (g_error_matches(error, G_IO_ERROR, G_IO_ERROR_WOULD_BLOCK)) {
                 *cond = G_IO_OUT;
@@ -1016,8 +1022,9 @@
         }
     } else {
         GError *error = NULL;
-        ret = g_pollable_input_stream_read_nonblocking(G_POLLABLE_INPUT_STREAM(c->in),
-                                                       data, len, NULL, &error);
+
+	ret = cloonix_g_socket_receive(c->sock, data, len, NULL, &error);
+
         if (ret < 0) {
             if (g_error_matches(error, G_IO_ERROR, G_IO_ERROR_WOULD_BLOCK)) {
                 *cond = G_IO_IN;
@@ -2216,6 +2223,7 @@
 
     g_return_val_if_fail(s != NULL, NULL);
 
+
     switch (type) {
     case SPICE_CHANNEL_MAIN:
         gtype = SPICE_TYPE_MAIN_CHANNEL;
@@ -2295,7 +2303,6 @@
 void spice_channel_destroy(SpiceChannel *channel)
 {
     g_return_if_fail(channel != NULL);
-
     CHANNEL_DEBUG(channel, "channel destroy");
     spice_channel_disconnect(channel, SPICE_CHANNEL_NONE);
     g_object_unref(channel);
@@ -2549,20 +2556,17 @@
             c->event = SPICE_CHANNEL_ERROR_CONNECT;
             goto cleanup;
         }
-
         if (!(c->sock = g_socket_new_from_fd(c->fd, NULL))) {
                 CHANNEL_DEBUG(channel, "Failed to open socket from fd %d", c->fd);
                 c->event = SPICE_CHANNEL_ERROR_CONNECT;
                 goto cleanup;
         }
-
         g_socket_set_blocking(c->sock, FALSE);
         g_socket_set_keepalive(c->sock, TRUE);
         c->conn = g_socket_connection_factory_create_connection(c->sock);
         goto connected;
     }
 
-
 reconnect:
     c->conn = spice_session_channel_open_host(c->session, channel, &c->tls, &c->error);
     if (c->conn == NULL) {
diff -Naur spice-gtk/src/spice-common.h tainted_spice/src/spice-common.h
--- spice-gtk/src/spice-common.h	2019-02-24 09:33:02.000000000 +0100
+++ tainted_spice/src/spice-common.h	2019-02-24 09:33:48.131773632 +0100
@@ -33,4 +33,13 @@
 
 #include "spice-util.h"
 
+
+#include <syslog.h>
+#define DKERR(format, a...)              \
+ do {                                                   \
+    syslog(LOG_ERR, "%s line:%d " format, \
+    __FUNCTION__,__LINE__, ## a);              \
+    } while (0)
+
+
 #endif // SPICE_COMMON_H_
diff -Naur spice-gtk/src/spice-session.c tainted_spice/src/spice-session.c
--- spice-gtk/src/spice-session.c	2019-02-24 09:33:02.000000000 +0100
+++ tainted_spice/src/spice-session.c	2019-02-24 09:33:48.131773632 +0100
@@ -19,9 +19,8 @@
 
 #include <gio/gio.h>
 #include <glib.h>
-#ifdef G_OS_UNIX
 #include <gio/gunixsocketaddress.h>
-#endif
+#include "cloonix.h"
 
 #include "spice-client.h"
 #include "spice-common.h"
@@ -33,11 +32,14 @@
 #include "channel-playback-priv.h"
 #include "spice-audio-priv.h"
 
+
 #define IMAGES_CACHE_SIZE_DEFAULT (1024 * 1024 * 80)
 #define MIN_GLZ_WINDOW_SIZE_DEFAULT (1024 * 1024 * 12)
 #define MAX_GLZ_WINDOW_SIZE_DEFAULT MIN((LZ_MAX_WINDOW_SIZE * 4), 1024 * 1024 * 64)
 
 struct _SpiceSessionPrivate {
+    char              *cloonix_doors;
+    char              *cloonix_spice;
     char              *host;
     char              *unix_path;
     char              *port;
@@ -158,6 +160,8 @@
 /* Properties */
 enum {
     PROP_0,
+    PROP_CLOONIX_DOORS,
+    PROP_CLOONIX_SPICE,
     PROP_HOST,
     PROP_PORT,
     PROP_TLS_PORT,
@@ -349,6 +353,8 @@
     SpiceSessionPrivate *s = session->priv;
 
     /* release stuff */
+    g_free(s->cloonix_doors);
+    g_free(s->cloonix_spice);
     g_free(s->unix_path);
     g_free(s->host);
     g_free(s->port);
@@ -414,7 +420,9 @@
 static int spice_parse_uri(SpiceSession *session, const char *original_uri)
 {
     SpiceSessionPrivate *s = session->priv;
-    gchar *host = NULL, *port = NULL, *tls_port = NULL, *uri = NULL, *username = NULL, *password = NULL;
+    gchar *host = NULL, *port = NULL, *tls_port = NULL;
+    gchar *uri = NULL, *username = NULL, *password = NULL;
+    gchar *cloonix_doors = NULL, *cloonix_spice = NULL;
     gchar *path = NULL;
     gchar *authority = NULL;
     gchar *query = NULL;
@@ -536,7 +544,11 @@
         }
 
         target_key = NULL;
-        if (g_str_equal(key, "port")) {
+        if (g_str_equal(key, "cloonix-doors")) {
+            target_key = &cloonix_doors;
+        } else if (g_str_equal(key, "cloonix-spice")) {
+            target_key = &cloonix_spice;
+        } else if (g_str_equal(key, "port")) {
             target_key = &port;
         } else if (g_str_equal(key, "tls-port")) {
             target_key = &tls_port;
@@ -556,13 +568,15 @@
         }
     }
 
-    if (port == NULL && tls_port == NULL) {
-        g_warning("Missing port or tls-port in spice URI '%s'", original_uri);
-        goto fail;
-    }
+//    if (port == NULL && tls_port == NULL) {
+//        g_warning("Missing port or tls-port in spice URI '%s'", original_uri);
+//        goto fail;
+//    }
 
 end:
     /* parsed ok -> apply */
+    g_free(s->cloonix_doors);
+    g_free(s->cloonix_spice);
     g_free(s->unix_path);
     g_free(s->host);
     g_free(s->port);
@@ -580,6 +594,8 @@
     }
     s->username = username;
     s->password = password;
+    s->cloonix_doors = cloonix_doors;
+    s->cloonix_spice = cloonix_spice;
     return 0;
 
 fail:
@@ -589,6 +605,8 @@
     g_free(tls_port);
     g_free(username);
     g_free(password);
+    g_free(cloonix_doors);
+    g_free(cloonix_spice);
     return -1;
 }
 
@@ -601,6 +619,14 @@
     SpiceSessionPrivate *s = session->priv;
 
     switch (prop_id) {
+
+    case PROP_CLOONIX_DOORS:
+        g_value_set_string(value, s->cloonix_doors);
+        break;
+    case PROP_CLOONIX_SPICE:
+        g_value_set_string(value, s->cloonix_spice);
+        break;
+
     case PROP_HOST:
         g_value_set_string(value, s->host);
 	break;
@@ -722,6 +748,16 @@
     const char *str;
 
     switch (prop_id) {
+
+    case PROP_CLOONIX_DOORS:
+        g_free(s->cloonix_doors);
+        s->cloonix_doors = g_value_dup_string(value);
+        break;
+    case PROP_CLOONIX_SPICE:
+        g_free(s->cloonix_spice);
+        s->cloonix_spice = g_value_dup_string(value);
+        break;
+
     case PROP_HOST:
         g_free(s->host);
         s->host = g_value_dup_string(value);
@@ -867,6 +903,42 @@
     gobject_class->get_property = spice_session_get_property;
     gobject_class->set_property = spice_session_set_property;
 
+
+    /**
+     * SpiceSession:cloonix_doors:
+     *
+     * Add of the cloonix server to connect to
+     *
+     **/
+    g_object_class_install_property
+        (gobject_class, PROP_CLOONIX_DOORS,
+         g_param_spec_string("cloonix-doors",
+                             "cloonix-doors",
+                             "cloonix-doors",
+                             NULL,
+                             G_PARAM_READWRITE |
+                             G_PARAM_CONSTRUCT |
+                             G_PARAM_STATIC_STRINGS));
+
+
+    /**
+     * SpiceSession:cloonix_spice:
+     *
+     * Unix socket access of the spice inside the cloonix server
+     *
+     **/
+    g_object_class_install_property
+        (gobject_class, PROP_CLOONIX_SPICE,
+         g_param_spec_string("cloonix-spice",
+                             "cloonix-spice",
+                             "cloonix-spice",
+                             NULL,
+                             G_PARAM_READWRITE |
+                             G_PARAM_CONSTRUCT |
+                             G_PARAM_STATIC_STRINGS));
+
+
+
     /**
      * SpiceSession:host:
      *
@@ -1569,6 +1641,8 @@
     c = copy->priv;
     g_clear_object(&c->proxy);
 
+    g_warn_if_fail(c->cloonix_doors == NULL);
+    g_warn_if_fail(c->cloonix_spice == NULL);
     g_warn_if_fail(c->host == NULL);
     g_warn_if_fail(c->unix_path == NULL);
     g_warn_if_fail(c->tls_port == NULL);
@@ -1582,6 +1656,8 @@
     g_warn_if_fail(c->proxy == NULL);
 
     g_object_get(session,
+                 "cloonix-doors", &c->cloonix_doors,
+                 "cloonix-spice", &c->cloonix_spice,
                  "host", &c->host,
                  "unix-path", &c->unix_path,
                  "tls-port", &c->tls_port,
@@ -2067,14 +2143,37 @@
     GSocketClient *client = G_SOCKET_CLIENT(source_object);
     spice_open_host *open_host = data;
     GSocketConnection *connection = NULL;
+    GSocket *gsock;
+    int sock;
+    int is_connected;
+    char *cloonix_spice;
+    char *password;
+
+    if (open_host->connection != NULL)
+      {
+      syslog(LOG_ERR, "TWO CONNECTS FOR ONE REQUEST");
+      exit(-1);
+      }
 
     CHANNEL_DEBUG(open_host->channel, "connect ready");
-    connection = g_socket_client_connect_finish(client, result, &open_host->error);
+    connection = g_socket_client_connect_finish(client, result, 
+                                                &open_host->error);
     if (connection == NULL) {
         g_warn_if_fail(open_host->error != NULL);
         goto end;
     }
-
+    is_connected = g_socket_connection_is_connected(connection);
+    gsock = g_socket_connection_get_socket(connection);
+    sock = g_socket_get_fd(gsock);
+  if ((!is_connected) || (!gsock) || (sock <= 0))
+    {
+    syslog(LOG_ERR, "%s CONNECT PB %d %p %d", __FUNCTION__, 
+                    is_connected, gsock, sock);
+    exit(-1);
+    }
+    cloonix_spice =(char *)spice_session_get_cloonix_spice(open_host->session);
+    password = (char *) spice_session_get_password(open_host->session);
+    cloonix_preliminaries(password, gsock, sock, cloonix_spice);
     open_host->connection = connection;
 
 end:
@@ -2082,10 +2181,12 @@
 }
 
 /* main context */
-static void open_host_connectable_connect(spice_open_host *open_host, GSocketConnectable *connectable)
+static void open_host_connectable_connect(spice_open_host *open_host, 
+                                          GSocketConnectable *connectable)
 {
     CHANNEL_DEBUG(open_host->channel, "connecting %p...", open_host);
 
+    open_host->connection = NULL;
     g_socket_client_connect_async(open_host->client, connectable,
                                   open_host->cancellable,
                                   socket_client_connect_ready, open_host);
@@ -2131,6 +2232,12 @@
 {
     spice_open_host *open_host = data;
     SpiceSessionPrivate *s;
+    GInetAddress *ip_addr;
+    GSocketAddress *address = NULL;
+//    GSocketConnectable *address = NULL;
+    char doors_ip[100];
+    int doors_port;
+
 
     g_return_val_if_fail(open_host != NULL, FALSE);
     g_return_val_if_fail(open_host->connection == NULL, FALSE);
@@ -2150,28 +2257,19 @@
                                         spice_uri_get_hostname(open_host->proxy),
                                         open_host->cancellable,
                                         proxy_lookup_ready, open_host);
-    } else {
-        GSocketConnectable *address = NULL;
-
-        if (s->unix_path) {
-            SPICE_DEBUG("open unix path %s", s->unix_path);
-#ifdef G_OS_UNIX
-            address = G_SOCKET_CONNECTABLE(g_unix_socket_address_new(s->unix_path));
-#else
-            g_set_error_literal(&open_host->error, SPICE_CLIENT_ERROR, SPICE_CLIENT_ERROR_FAILED,
-                                "Unix path unsupported on this platform");
-#endif
-        } else {
-            SPICE_DEBUG("open host %s:%d", s->host, open_host->port);
-            address = g_network_address_parse(s->host, open_host->port, &open_host->error);
-        }
-
-        if (address == NULL || open_host->error != NULL) {
-            coroutine_yieldto(open_host->from, NULL);
-            return FALSE;
-        }
-
-        open_host_connectable_connect(open_host, address);
+    } 
+    else {
+        if (get_address_from_param(s->cloonix_doors, doors_ip, &doors_port))
+            {
+            ip_addr = g_inet_address_new_from_string(doors_ip);
+            address = g_inet_socket_address_new(ip_addr, doors_port);
+            }
+        else
+            {
+            syslog(LOG_ERR, "%s", s->cloonix_doors);
+            exit(-1);
+            }
+        open_host_connectable_connect(open_host, G_SOCKET_CONNECTABLE(address));
         g_object_unref(address);
     }
 
@@ -2188,15 +2286,18 @@
 
 /* coroutine context */
 G_GNUC_INTERNAL
-GSocketConnection* spice_session_channel_open_host(SpiceSession *session, SpiceChannel *channel,
-                                                   gboolean *use_tls, GError **error)
+GSocketConnection* spice_session_channel_open_host(SpiceSession *session, 
+                                                   SpiceChannel *channel,
+                                                   gboolean *use_tls, 
+                                                   GError **error)
 {
     g_return_val_if_fail(SPICE_IS_SESSION(session), NULL);
 
     SpiceSessionPrivate *s = session->priv;
     SpiceChannelPrivate *c = channel->priv;
     spice_open_host open_host = { 0, };
-    gchar *port, *endptr;
+ //   gchar *port, *endptr;
+
 
     // FIXME: make open_host() cancellable
     open_host.from = coroutine_self();
@@ -2208,31 +2309,6 @@
         spice_strv_contains(s->secure_channels, name))
         *use_tls = TRUE;
 
-    if (s->unix_path) {
-        if (*use_tls) {
-            CHANNEL_DEBUG(channel, "No TLS for Unix sockets");
-            return NULL;
-        }
-    } else {
-        port = *use_tls ? s->tls_port : s->port;
-        if (port == NULL) {
-            SPICE_DEBUG("Missing port value, not attempting %s connection.",
-                    *use_tls?"TLS":"unencrypted");
-            return NULL;
-        }
-
-        open_host.port = strtol(port, &endptr, 10);
-        if (*port == '\0' || *endptr != '\0' ||
-            open_host.port <= 0 || open_host.port > G_MAXUINT16) {
-            g_warning("Invalid port value %s", port);
-            return NULL;
-        }
-    }
-    if (*use_tls) {
-        CHANNEL_DEBUG(channel, "Using TLS, port %d", open_host.port);
-    } else {
-        CHANNEL_DEBUG(channel, "Using plain text, port %d", open_host.port);
-    }
 
     open_host.client = g_socket_client_new();
     g_socket_client_set_enable_proxy(open_host.client, s->proxy != NULL);
@@ -2476,6 +2552,27 @@
 }
 
 G_GNUC_INTERNAL
+const gchar* spice_session_get_cloonix_doors(SpiceSession *session)
+{
+    g_return_val_if_fail(SPICE_IS_SESSION(session), NULL);
+
+    SpiceSessionPrivate *s = session->priv;
+
+    return s->cloonix_doors;
+}
+
+G_GNUC_INTERNAL
+const gchar* spice_session_get_cloonix_spice(SpiceSession *session)
+{
+    g_return_val_if_fail(SPICE_IS_SESSION(session), NULL);
+
+    SpiceSessionPrivate *s = session->priv;
+
+    return s->cloonix_spice;
+}
+
+
+G_GNUC_INTERNAL
 const gchar* spice_session_get_host(SpiceSession *session)
 {
     g_return_val_if_fail(SPICE_IS_SESSION(session), NULL);
diff -Naur spice-gtk/src/spice-session-priv.h tainted_spice/src/spice-session-priv.h
--- spice-gtk/src/spice-session-priv.h	2019-02-24 09:33:02.000000000 +0100
+++ tainted_spice/src/spice-session-priv.h	2019-02-24 09:33:48.131773632 +0100
@@ -63,6 +63,8 @@
 void spice_session_get_pubkey(SpiceSession *session, guint8 **pubkey, guint *size);
 guint spice_session_get_verify(SpiceSession *session);
 const gchar* spice_session_get_username(SpiceSession *session);
+const gchar* spice_session_get_cloonix_doors(SpiceSession *session);
+const gchar* spice_session_get_cloonix_spice(SpiceSession *session);
 const gchar* spice_session_get_password(SpiceSession *session);
 const gchar* spice_session_get_host(SpiceSession *session);
 const gchar* spice_session_get_cert_subject(SpiceSession *session);
diff -Naur spice-gtk/src/spice-widget-egl.c tainted_spice/src/spice-widget-egl.c
--- spice-gtk/src/spice-widget-egl.c	2019-02-24 09:33:02.000000000 +0100
+++ tainted_spice/src/spice-widget-egl.c	2019-02-24 09:33:48.131773632 +0100
@@ -220,7 +220,7 @@
 #endif
 
     d->egl.display = eglGetDisplay(dpy);
-    if (d->egl.display == EGL_NO_DISPLAY) {
+    if (d->egl.display == 0) {
         g_set_error_literal(err, SPICE_CLIENT_ERROR, SPICE_CLIENT_ERROR_FAILED,
                             "failed to get EGL display");
         return FALSE;
@@ -258,7 +258,7 @@
 
     d->egl.ctx = eglCreateContext(d->egl.display,
                                   d->egl.conf,
-                                  EGL_NO_CONTEXT,
+                                  0,
                                   ctx_att);
     if (!d->egl.ctx) {
         g_set_error_literal(err, SPICE_CLIENT_ERROR, SPICE_CLIENT_ERROR_FAILED,
@@ -266,7 +266,7 @@
         return FALSE;
     }
 
-    eglMakeCurrent(d->egl.display, EGL_NO_SURFACE, EGL_NO_SURFACE,
+    eglMakeCurrent(d->egl.display, 0, 0,
                    d->egl.ctx);
 
 #ifdef GDK_WINDOWING_WAYLAND
@@ -407,9 +407,9 @@
         /* egl.surface && egl.ctx are only created on x11, see
            spice_egl_init() */
 
-        if (d->egl.surface != EGL_NO_SURFACE) {
+        if (d->egl.surface != 0) {
             eglDestroySurface(d->egl.display, d->egl.surface);
-            d->egl.surface = EGL_NO_SURFACE;
+            d->egl.surface = 0;
         }
 
         if (d->egl.ctx) {
@@ -417,8 +417,8 @@
             d->egl.ctx = 0;
         }
 
-        eglMakeCurrent(d->egl.display, EGL_NO_SURFACE, EGL_NO_SURFACE,
-                       EGL_NO_CONTEXT);
+        eglMakeCurrent(d->egl.display, 0, 0,
+                       0);
 
         /* do not call eglterminate() since egl may be used by
          * somebody else code */
@@ -669,7 +669,7 @@
                   (int)(format >> 16) & 0xff, (int)format >> 24);
 
     d->egl.image = eglCreateImageKHR(d->egl.display,
-                                       EGL_NO_CONTEXT,
+                                       0,
                                        EGL_LINUX_DMA_BUF_EXT,
                                        (EGLClientBuffer)NULL,
                                        attrs);
diff -Naur spice-gtk/tools/spice-cmdline.c tainted_spice/tools/spice-cmdline.c
--- spice-gtk/tools/spice-cmdline.c	2019-02-24 09:33:02.000000000 +0100
+++ tainted_spice/tools/spice-cmdline.c	2019-02-24 09:33:48.131773632 +0100
@@ -27,9 +27,25 @@
 static char *tls_port;
 static char *password;
 static char *uri;
+static char *cloonix_doors;
+static char *cloonix_spice;
 
 static GOptionEntry spice_entries[] = {
-    {
+   {
+        .long_name        = "cloonix-doors",
+        .short_name       = 'd',
+        .arg              = G_OPTION_ARG_STRING,
+        .arg_data         = &cloonix_doors,
+        .description      = N_("Cloonix door path"),
+        .arg_description  = N_("<cloonix_doors>"),
+    },{
+        .long_name        = "cloonix-spice",
+        .short_name       = 'c',
+        .arg              = G_OPTION_ARG_STRING,
+        .arg_data         = &cloonix_spice,
+        .description      = N_("Cloonix spice server path"),
+        .arg_description  = N_("<cloonix_spice>"),
+    },{
         .long_name        = "uri",
         .arg              = G_OPTION_ARG_STRING,
         .arg_data         = &uri,
@@ -85,6 +101,10 @@
 {
     g_return_if_fail(SPICE_IS_SESSION(session));
 
+    if (cloonix_doors)
+        g_object_set(session, "cloonix-doors", cloonix_doors, NULL);
+    if (cloonix_spice)
+        g_object_set(session, "cloonix-spice", cloonix_spice, NULL);
     if (uri)
         g_object_set(session, "uri", uri, NULL);
     if (host)
diff -Naur spice-gtk/tools/spicy.c tainted_spice/tools/spicy.c
--- spice-gtk/tools/spicy.c	2019-02-24 09:33:02.000000000 +0100
+++ tainted_spice/tools/spicy.c	2019-02-24 09:33:48.131773632 +0100
@@ -1971,7 +1971,6 @@
     GOptionContext *context;
     spice_connection *conn;
     gchar *conf_file, *conf;
-    char *host = NULL, *port = NULL, *tls_port = NULL, *unix_path = NULL;
 
     keyfile = g_key_file_new();
 
@@ -2016,23 +2015,6 @@
     spice_set_session_option(conn->session);
     spice_cmdline_session_setup(conn->session);
 
-    g_object_get(conn->session,
-                 "unix-path", &unix_path,
-                 "host", &host,
-                 "port", &port,
-                 "tls-port", &tls_port,
-                 NULL);
-    /* If user doesn't provide hostname and port, show the dialog window
-       instead of connecting to server automatically */
-    if ((host == NULL || (port == NULL && tls_port == NULL)) && unix_path == NULL) {
-        if (!spicy_connect_dialog(conn->session)) {
-            exit(0);
-        }
-    }
-    g_free(host);
-    g_free(port);
-    g_free(tls_port);
-    g_free(unix_path);
 
     connection_connect(conn);
     if (connections > 0)
