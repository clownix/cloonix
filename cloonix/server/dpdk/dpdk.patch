diff -Naur dpdk/drivers/meson.build dpdk_tainted/drivers/meson.build
--- dpdk/drivers/meson.build	2021-12-23 19:26:29.000000000 +0100
+++ dpdk_tainted/drivers/meson.build	2021-12-24 12:12:06.871226686 +0100
@@ -164,6 +164,7 @@
         tmp_lib = static_library('tmp_' + lib_name, sources,
                 include_directories: includes,
                 dependencies: static_deps,
+                install_rpath : '/usr/local/bin/cloonix/server/dpdk/lib',
                 c_args: cflags)
         objs += tmp_lib.extract_all_objects(recursive: true)
         sources = custom_target(out_filename,
@@ -228,6 +229,7 @@
                 version: abi_version,
                 soversion: so_version,
                 install: true,
+                install_rpath : '/usr/local/bin/cloonix/server/dpdk/lib',
                 install_dir: driver_install_path)
 
         # create a dependency object and add it to the global dictionary so
diff -Naur dpdk/drivers/net/virtio/virtio_ethdev.c dpdk_tainted/drivers/net/virtio/virtio_ethdev.c
--- dpdk/drivers/net/virtio/virtio_ethdev.c	2021-12-23 19:26:29.000000000 +0100
+++ dpdk_tainted/drivers/net/virtio/virtio_ethdev.c	2021-12-24 12:12:06.871226686 +0100
@@ -2226,9 +2226,12 @@
 	hw->weak_barriers = !virtio_with_feature(hw, VIRTIO_F_ORDER_PLATFORM);
 
 	/* If host does not support both status and MSI-X then disable LSC */
-	if (virtio_with_feature(hw, VIRTIO_NET_F_STATUS) && hw->intr_lsc)
-		eth_dev->data->dev_flags |= RTE_ETH_DEV_INTR_LSC;
-	else
+
+// cloonix
+//	if (virtio_with_feature(hw, VIRTIO_NET_F_STATUS) && hw->intr_lsc)
+//		eth_dev->data->dev_flags |= RTE_ETH_DEV_INTR_LSC;
+//	else
+//
 		eth_dev->data->dev_flags &= ~RTE_ETH_DEV_INTR_LSC;
 
 	eth_dev->data->dev_flags |= RTE_ETH_DEV_AUTOFILL_QUEUE_XSTATS;
diff -Naur dpdk/drivers/net/virtio/virtio_user/virtio_user_dev.c dpdk_tainted/drivers/net/virtio/virtio_user/virtio_user_dev.c
--- dpdk/drivers/net/virtio/virtio_user/virtio_user_dev.c	2021-12-23 19:26:29.000000000 +0100
+++ dpdk_tainted/drivers/net/virtio/virtio_user/virtio_user_dev.c	2021-12-24 12:12:06.871226686 +0100
@@ -327,8 +327,9 @@
 	} else {
 		ret = virtio_user_dev_get_mac(dev);
 		if (ret) {
-			PMD_DRV_LOG(ERR, "(%s) No valid MAC in devargs or device, use random",
-					dev->path);
+//cloonix no-use log
+//			PMD_DRV_LOG(ERR, "(%s) No valid MAC in devargs or device, use random",
+//					dev->path);
 			return;
 		}
 
diff -Naur dpdk/lib/eal/common/eal_common_fbarray.c dpdk_tainted/lib/eal/common/eal_common_fbarray.c
--- dpdk/lib/eal/common/eal_common_fbarray.c	2021-12-23 19:26:29.000000000 +0100
+++ dpdk_tainted/lib/eal/common/eal_common_fbarray.c	2021-12-24 12:12:06.871226686 +0100
@@ -23,6 +23,8 @@
 
 #include "rte_fbarray.h"
 
+
+
 #define MASK_SHIFT 6ULL
 #define MASK_ALIGN (1ULL << MASK_SHIFT)
 #define MASK_LEN_TO_IDX(x) ((x) >> MASK_SHIFT)
@@ -45,6 +47,8 @@
 	TAILQ_HEAD_INITIALIZER(mem_area_tailq);
 static rte_spinlock_t mem_area_lock = RTE_SPINLOCK_INITIALIZER;
 
+static rte_spinlock_t g_cloonix_biglock = RTE_SPINLOCK_INITIALIZER;
+
 /*
  * This is a mask that is always stored at the end of array, to provide fast
  * way of finding free/used spots without looping through each element.
@@ -124,6 +128,7 @@
 	unsigned int last, last_mod;
 	uint64_t last_msk, ignore_msk;
 
+rte_fbarray_cloonix_biglock_test(__FILE__, __LINE__);
 	/*
 	 * mask only has granularity of MASK_ALIGN, but start may not be aligned
 	 * on that boundary, so construct a special mask to exclude anything we
@@ -272,6 +277,7 @@
 	unsigned int last, last_mod;
 	uint64_t last_msk, ignore_msk;
 
+//rte_fbarray_cloonix_biglock_test(__FILE__, __LINE__);
 	/*
 	 * mask only has granularity of MASK_ALIGN, but start may not be aligned
 	 * on that boundary, so construct a special mask to exclude anything we
@@ -288,6 +294,13 @@
 	last_mod = MASK_LEN_TO_MOD(arr->len);
 	last_msk = ~(-(1ULL) << last_mod);
 
+        __sync_synchronize();
+	if (arr->cloonix_rwlock == 0)
+	    KERR("ERROR OOOOOO %s %d %p %d %d start:%d used:%d %p",
+                 arr->name, arr->cloonix_rwlock, arr->data,
+                 arr->len, arr->elt_sz, start, used, msk);
+        else
+{
 	for (idx = first; idx < msk->n_masks; idx++) {
 		uint64_t cur = msk->data[idx];
 		int found;
@@ -314,6 +327,7 @@
 		found = __builtin_ctzll(cur);
 		return MASK_GET_IDX(idx, found);
 	}
+}
 	/* we didn't find anything */
 	rte_errno = used ? ENOENT : ENOSPC;
 	return -1;
@@ -389,6 +403,7 @@
 	unsigned int msk_idx, lookbehind_idx, first, first_mod;
 	uint64_t ignore_msk;
 
+rte_fbarray_cloonix_biglock_test(__FILE__, __LINE__);
 	/*
 	 * mask only has granularity of MASK_ALIGN, but start may not be aligned
 	 * on that boundary, so construct a special mask to exclude anything we
@@ -551,6 +566,7 @@
 	unsigned int idx, first, first_mod;
 	uint64_t ignore_msk;
 
+rte_fbarray_cloonix_biglock_test(__FILE__, __LINE__);
 	/*
 	 * mask only has granularity of MASK_ALIGN, but start may not be aligned
 	 * on that boundary, so construct a special mask to exclude anything we
@@ -815,13 +831,19 @@
 	msk->n_masks = MASK_LEN_TO_IDX(RTE_ALIGN_CEIL(len, MASK_ALIGN));
 
 	rte_rwlock_init(&arr->rwlock);
+	__sync_lock_test_and_set(&(arr->cloonix_rwlock), 1);
 
 	rte_spinlock_unlock(&mem_area_lock);
 
 	return 0;
 fail:
 	if (data)
+                {
+	        KERR("ERROR OOOOOO %s %d %p %d %d",arr->name,
+                      arr->cloonix_rwlock, arr->data, arr->len, arr->elt_sz);
+	        __sync_lock_test_and_set(&(arr->cloonix_rwlock), 0);
 		rte_mem_unmap(data, mmap_len);
+                }
 	if (fd >= 0)
 		close(fd);
 	free(ma);
@@ -898,6 +920,7 @@
 		goto fail;
 
 	/* store our new memory area */
+	__sync_lock_test_and_set(&(arr->cloonix_rwlock), 2);
 	ma->addr = data;
 	ma->fd = fd; /* keep fd until detach/destroy */
 	ma->len = mmap_len;
@@ -910,7 +933,12 @@
 	return 0;
 fail:
 	if (data)
+                {
+	        KERR("ERROR OOOOOO %s %d %p %d %d",arr->name,
+                     arr->cloonix_rwlock, arr->data, arr->len, arr->elt_sz);
+	        __sync_lock_test_and_set(&(arr->cloonix_rwlock), 0);
 		rte_mem_unmap(data, mmap_len);
+                }
 	if (fd >= 0)
 		close(fd);
 	free(ma);
@@ -957,6 +985,7 @@
 		goto out;
 	}
 
+	__sync_lock_test_and_set(&(arr->cloonix_rwlock), 0);
 	rte_mem_unmap(arr->data, mmap_len);
 
 	/* area is unmapped, close fd and remove the tailq entry */
@@ -1043,6 +1072,7 @@
 		}
 		close(fd);
 	}
+	__sync_lock_test_and_set(&(arr->cloonix_rwlock), 0);
 	rte_mem_unmap(arr->data, mmap_len);
 
 	/* area is unmapped, remove the tailq entry */
@@ -1502,3 +1532,44 @@
 out:
 	rte_rwlock_read_unlock(&arr->rwlock);
 }
+
+
+void
+rte_fbarray_cloonix_biglock_test(const char *name, int line)
+{
+  int was_locked = rte_spinlock_is_locked(&g_cloonix_biglock);
+  if (was_locked == 0)
+    KERR("ERROR ERROR NOT LOCKED OOOOOO ERROR ERROR ERROR %s %d", name, line);
+}
+
+
+void
+rte_fbarray_cloonix_biglock_on(const char *name, int line)
+{
+//  static char old_name[200];
+//  static int old_line;
+//  int was_locked;
+//
+//  was_locked = rte_spinlock_is_locked(&g_cloonix_biglock);
+//  if (was_locked)
+//    {
+//    KERR("ERROR LOCKED CUR  OOOOOO %s %d", name, line);
+//    KERR("ERROR LOCKED PREV OOOOOO %s %d", old_name, old_line);
+//    }
+
+  rte_spinlock_lock(&g_cloonix_biglock);
+
+//  if (was_locked)
+//    KERR("UNERROR UNLOCKED OOOOOO %s %d", name, line);
+//
+//  memset(old_name, 0, 200);
+//  strncpy(old_name, name, 199);
+//  old_line = line;
+}
+
+void
+rte_fbarray_cloonix_biglock_off(void)
+{
+  rte_spinlock_unlock(&g_cloonix_biglock);
+}
+
diff -Naur dpdk/lib/eal/common/eal_common_memzone.c dpdk_tainted/lib/eal/common/eal_common_memzone.c
--- dpdk/lib/eal/common/eal_common_memzone.c	2021-12-23 19:26:29.000000000 +0100
+++ dpdk_tainted/lib/eal/common/eal_common_memzone.c	2021-12-24 12:12:06.871226686 +0100
@@ -236,8 +236,12 @@
 rte_memzone_reserve_bounded(const char *name, size_t len, int socket_id,
 			    unsigned flags, unsigned align, unsigned bound)
 {
-	return rte_memzone_reserve_thread_safe(name, len, socket_id, flags,
-					       align, bound);
+	struct rte_memzone *result;
+rte_fbarray_cloonix_biglock_on(__FILE__, __LINE__);
+	result = rte_memzone_reserve_thread_safe(name, len, socket_id, flags,
+                                               align, bound);
+rte_fbarray_cloonix_biglock_off();
+	return result;
 }
 
 /*
@@ -248,8 +252,11 @@
 rte_memzone_reserve_aligned(const char *name, size_t len, int socket_id,
 			    unsigned flags, unsigned align)
 {
-	return rte_memzone_reserve_thread_safe(name, len, socket_id, flags,
+	struct rte_memzone *result;
+rte_fbarray_cloonix_biglock_test(__FILE__, __LINE__);
+	result = rte_memzone_reserve_thread_safe(name, len, socket_id, flags,
 					       align, 0);
+	return result;
 }
 
 /*
@@ -260,8 +267,11 @@
 rte_memzone_reserve(const char *name, size_t len, int socket_id,
 		    unsigned flags)
 {
-	return rte_memzone_reserve_thread_safe(name, len, socket_id,
+	struct rte_memzone *result;
+rte_fbarray_cloonix_biglock_test(__FILE__, __LINE__);
+	result = rte_memzone_reserve_thread_safe(name, len, socket_id,
 					       flags, RTE_CACHE_LINE_SIZE, 0);
+	return result;
 }
 
 int
diff -Naur dpdk/lib/eal/common/eal_common_options.c dpdk_tainted/lib/eal/common/eal_common_options.c
--- dpdk/lib/eal/common/eal_common_options.c	2021-12-23 19:26:29.000000000 +0100
+++ dpdk_tainted/lib/eal/common/eal_common_options.c	2021-12-24 12:12:06.871226686 +0100
@@ -125,7 +125,9 @@
 
 #ifndef RTE_EXEC_ENV_WINDOWS
 /* Default path of external loadable drivers */
-static const char *default_solib_dir = RTE_EAL_PMD_PATH;
+//static const char *default_solib_dir = RTE_EAL_PMD_PATH;
+static const char *default_solib_dir = "/usr/local/bin/cloonix/server/dpdk/lib";
+
 #endif
 
 /*
diff -Naur dpdk/lib/eal/common/rte_malloc.c dpdk_tainted/lib/eal/common/rte_malloc.c
--- dpdk/lib/eal/common/rte_malloc.c	2021-12-23 19:26:29.000000000 +0100
+++ dpdk_tainted/lib/eal/common/rte_malloc.c	2021-12-24 12:12:06.871226686 +0100
@@ -484,6 +484,7 @@
 		goto unlock;
 	}
 
+rte_fbarray_cloonix_biglock_on(__FILE__, __LINE__);
 	msl = malloc_heap_find_external_seg(va_addr, len);
 	if (msl == NULL) {
 		ret = -1;
@@ -499,6 +500,7 @@
 	ret = malloc_heap_destroy_external_seg(msl);
 
 unlock:
+rte_fbarray_cloonix_biglock_off();
 	rte_mcfg_mem_write_unlock();
 
 	return ret;
@@ -534,6 +536,7 @@
 		goto unlock;
 	}
 
+rte_fbarray_cloonix_biglock_on(__FILE__, __LINE__);
 	/* find corresponding memseg list to sync to */
 	msl = malloc_heap_find_external_seg(va_addr, len);
 	if (msl == NULL) {
@@ -541,6 +544,7 @@
 		goto unlock;
 	}
 
+
 	if (attach) {
 		ret = rte_fbarray_attach(&msl->memseg_arr);
 		if (ret == 0) {
@@ -566,6 +570,9 @@
 		}
 	}
 unlock:
+
+rte_fbarray_cloonix_biglock_off();
+
 	rte_mcfg_mem_read_unlock();
 	return ret;
 }
diff -Naur dpdk/lib/eal/include/rte_fbarray.h dpdk_tainted/lib/eal/include/rte_fbarray.h
--- dpdk/lib/eal/include/rte_fbarray.h	2021-12-23 19:26:29.000000000 +0100
+++ dpdk_tainted/lib/eal/include/rte_fbarray.h	2021-12-24 12:12:06.871226686 +0100
@@ -39,6 +39,18 @@
 #include <rte_compat.h>
 #include <rte_rwlock.h>
 
+
+#include <syslog.h>
+#define KERR(format, a...)                               \
+ do {                                                    \
+    syslog(LOG_ERR | LOG_USER, "%s"                 \
+    " line:%d " format "\n",   \
+    (strrchr(__FILE__, '/') ? strrchr(__FILE__, '/') + 1 : __FILE__), \
+     __LINE__, ## a);                                    \
+    } while (0)
+
+
+
 #define RTE_FBARRAY_NAME_LEN 64
 
 struct rte_fbarray {
@@ -48,6 +60,7 @@
 	unsigned int elt_sz;             /**< size of each element */
 	void *data;                      /**< data pointer */
 	rte_rwlock_t rwlock;             /**< multiprocess lock */
+	volatile uint32_t cloonix_rwlock;
 };
 
 /**
@@ -532,6 +545,16 @@
 void
 rte_fbarray_dump_metadata(struct rte_fbarray *arr, FILE *f);
 
+void
+rte_fbarray_cloonix_biglock_test(const char *name, int line);
+
+void
+rte_fbarray_cloonix_biglock_on(const char *name, int line);
+
+void
+rte_fbarray_cloonix_biglock_off(void);
+
+
 #ifdef __cplusplus
 }
 #endif
diff -Naur dpdk/lib/eal/linux/eal.c dpdk_tainted/lib/eal/linux/eal.c
--- dpdk/lib/eal/linux/eal.c	2021-12-23 19:26:29.000000000 +0100
+++ dpdk_tainted/lib/eal/linux/eal.c	2021-12-24 12:14:06.275227069 +0100
@@ -93,21 +93,19 @@
 {
 	const char *directory = default_runtime_dir;
 	const char *xdg_runtime_dir = getenv("XDG_RUNTIME_DIR");
-	const char *fallback = "/tmp";
 	char run_dir[PATH_MAX];
 	char tmp[PATH_MAX];
 	int ret;
-
-	if (getuid() != 0) {
-		/* try XDG path first, fall back to /tmp */
-		if (xdg_runtime_dir != NULL)
-			directory = xdg_runtime_dir;
-		else
-			directory = fallback;
-	}
+        if (xdg_runtime_dir != NULL)
+            directory = xdg_runtime_dir;
+        else {
+            syslog(LOG_ERR | LOG_USER, "ERROR xdg_runtime_dir NOT DEFINED\n");
+            return -1;
+        }
 	/* create DPDK subdirectory under runtime dir */
 	ret = snprintf(tmp, sizeof(tmp), "%s/dpdk", directory);
 	if (ret < 0 || ret == sizeof(tmp)) {
+                syslog(LOG_ERR | LOG_USER, "ERROR RUNTIME DIR\n");
 		RTE_LOG(ERR, EAL, "Error creating DPDK runtime path name\n");
 		return -1;
 	}
@@ -116,6 +114,7 @@
 	ret = snprintf(run_dir, sizeof(run_dir), "%s/%s",
 			tmp, eal_get_hugefile_prefix());
 	if (ret < 0 || ret == sizeof(run_dir)) {
+                syslog(LOG_ERR | LOG_USER, "ERROR RUNTIME DIR\n");
 		RTE_LOG(ERR, EAL, "Error creating prefix-specific runtime path name\n");
 		return -1;
 	}
@@ -125,6 +124,7 @@
 	 */
 	ret = mkdir(tmp, 0700);
 	if (ret < 0 && errno != EEXIST) {
+                syslog(LOG_ERR | LOG_USER, "ERROR RUNTIME DIR %s\n", tmp);
 		RTE_LOG(ERR, EAL, "Error creating '%s': %s\n",
 			tmp, strerror(errno));
 		return -1;
@@ -132,13 +132,17 @@
 
 	ret = mkdir(run_dir, 0700);
 	if (ret < 0 && errno != EEXIST) {
+                syslog(LOG_ERR | LOG_USER, "ERROR RUNTIME DIR %s\n", run_dir);
 		RTE_LOG(ERR, EAL, "Error creating '%s': %s\n",
 			run_dir, strerror(errno));
 		return -1;
 	}
 
 	if (eal_set_runtime_dir(run_dir, sizeof(run_dir)))
+                {
+                syslog(LOG_ERR | LOG_USER, "ERROR RUNTIME DIR %s\n", run_dir);
 		return -1;
+                }
 
 	return 0;
 }
@@ -295,6 +299,7 @@
 	if (mem_cfg_fd < 0){
 		mem_cfg_fd = open(pathname, O_RDWR | O_CREAT, 0600);
 		if (mem_cfg_fd < 0) {
+KERR("ERROR CONFIG CREATE: %s", pathname);
 			RTE_LOG(ERR, EAL, "Cannot open '%s' for rte_mem_config\n",
 				pathname);
 			return -1;
@@ -303,6 +308,7 @@
 
 	retval = ftruncate(mem_cfg_fd, cfg_len);
 	if (retval < 0){
+KERR("ERROR CONFIG CREATE: %s", pathname);
 		close(mem_cfg_fd);
 		mem_cfg_fd = -1;
 		RTE_LOG(ERR, EAL, "Cannot resize '%s' for rte_mem_config\n",
@@ -312,6 +318,7 @@
 
 	retval = fcntl(mem_cfg_fd, F_SETLK, &wr_lock);
 	if (retval < 0){
+KERR("ERROR CONFIG CREATE: %s", pathname);
 		close(mem_cfg_fd);
 		mem_cfg_fd = -1;
 		RTE_LOG(ERR, EAL, "Cannot create lock on '%s'. Is another primary "
@@ -323,6 +330,7 @@
 	rte_mem_cfg_addr = eal_get_virtual_area(rte_mem_cfg_addr,
 			&cfg_len_aligned, page_sz, 0, 0);
 	if (rte_mem_cfg_addr == NULL) {
+KERR("ERROR CONFIG CREATE: %s", pathname);
 		RTE_LOG(ERR, EAL, "Cannot mmap memory for rte_config\n");
 		close(mem_cfg_fd);
 		mem_cfg_fd = -1;
@@ -334,6 +342,7 @@
 			cfg_len_aligned, PROT_READ | PROT_WRITE,
 			MAP_SHARED | MAP_FIXED, mem_cfg_fd, 0);
 	if (mapped_mem_cfg_addr == MAP_FAILED) {
+KERR("ERROR CONFIG CREATE: %s", pathname);
 		munmap(rte_mem_cfg_addr, cfg_len);
 		close(mem_cfg_fd);
 		mem_cfg_fd = -1;
@@ -370,6 +379,7 @@
 	if (mem_cfg_fd < 0){
 		mem_cfg_fd = open(pathname, O_RDWR);
 		if (mem_cfg_fd < 0) {
+KERR("ERROR rte_eal_config_attach %s", pathname);
 			RTE_LOG(ERR, EAL, "Cannot open '%s' for rte_mem_config\n",
 				pathname);
 			return -1;
@@ -382,6 +392,7 @@
 	if (mem_config == MAP_FAILED) {
 		close(mem_cfg_fd);
 		mem_cfg_fd = -1;
+KERR("ERROR rte_eal_config_attach %s %i (%s)", pathname, errno, strerror(errno));
 		RTE_LOG(ERR, EAL, "Cannot mmap memory for rte_config! error %i (%s)\n",
 			errno, strerror(errno));
 		return -1;
@@ -484,15 +495,23 @@
 		break;
 	case RTE_PROC_SECONDARY:
 		if (rte_eal_config_attach() < 0)
+                        {
+KERR("ERROR RTE CONFIG");
 			return -1;
+                        }
 		eal_mcfg_wait_complete();
 		if (eal_mcfg_check_version() < 0) {
+KERR("ERROR RTE CONFIG");
 			RTE_LOG(ERR, EAL, "Primary and secondary process DPDK version mismatch\n");
 			return -1;
 		}
 		if (rte_eal_config_reattach() < 0)
+                        {
+KERR("ERROR RTE CONFIG");
 			return -1;
+                        }
 		if (!__rte_mp_enable()) {
+KERR("ERROR RTE CONFIG");
 			RTE_LOG(ERR, EAL, "Primary process refused secondary attachment\n");
 			return -1;
 		}
@@ -500,6 +519,7 @@
 		break;
 	case RTE_PROC_AUTO:
 	case RTE_PROC_INVALID:
+KERR("ERROR RTE CONFIG");
 		RTE_LOG(ERR, EAL, "Invalid process type %d\n",
 			config->process_type);
 		return -1;
@@ -975,10 +995,14 @@
 	struct internal_config *internal_conf =
 		eal_get_internal_configuration();
 
+rte_fbarray_cloonix_biglock_on(__FILE__, __LINE__);
+
 	/* checks if the machine is adequate */
 	if (!rte_cpu_is_supported()) {
 		rte_eal_init_alert("unsupported cpu type.");
 		rte_errno = ENOTSUP;
+rte_fbarray_cloonix_biglock_off();
+KERR("ERROR EAL");
 		return -1;
 	}
 
@@ -986,6 +1010,8 @@
 					__ATOMIC_RELAXED, __ATOMIC_RELAXED)) {
 		rte_eal_init_alert("already called initialization.");
 		rte_errno = EALREADY;
+rte_fbarray_cloonix_biglock_off();
+KERR("ERROR EAL");
 		return -1;
 	}
 
@@ -1004,6 +1030,8 @@
 	if (rte_eal_cpu_init() < 0) {
 		rte_eal_init_alert("Cannot detect lcores.");
 		rte_errno = ENOTSUP;
+rte_fbarray_cloonix_biglock_off();
+KERR("ERROR EAL");
 		return -1;
 	}
 
@@ -1012,6 +1040,8 @@
 		rte_eal_init_alert("Invalid 'command line' arguments.");
 		rte_errno = EINVAL;
 		__atomic_store_n(&run_once, 0, __ATOMIC_RELAXED);
+rte_fbarray_cloonix_biglock_off();
+KERR("ERROR EAL");
 		return -1;
 	}
 
@@ -1019,34 +1049,46 @@
 		rte_eal_init_alert("Cannot init plugins");
 		rte_errno = EINVAL;
 		__atomic_store_n(&run_once, 0, __ATOMIC_RELAXED);
+rte_fbarray_cloonix_biglock_off();
+KERR("ERROR EAL");
 		return -1;
 	}
 
 	if (eal_trace_init() < 0) {
 		rte_eal_init_alert("Cannot init trace");
 		rte_errno = EFAULT;
+rte_fbarray_cloonix_biglock_off();
+KERR("ERROR EAL");
 		return -1;
 	}
 
 	if (eal_option_device_parse()) {
 		rte_errno = ENODEV;
 		__atomic_store_n(&run_once, 0, __ATOMIC_RELAXED);
+rte_fbarray_cloonix_biglock_off();
+KERR("ERROR EAL");
 		return -1;
 	}
 
 	if (rte_config_init() < 0) {
 		rte_eal_init_alert("Cannot init config");
+rte_fbarray_cloonix_biglock_off();
+KERR("ERROR EAL");
 		return -1;
 	}
 
 	if (rte_eal_intr_init() < 0) {
 		rte_eal_init_alert("Cannot init interrupt-handling thread");
+rte_fbarray_cloonix_biglock_off();
+KERR("ERROR EAL");
 		return -1;
 	}
 
 	if (rte_eal_alarm_init() < 0) {
 		rte_eal_init_alert("Cannot init alarm");
 		/* rte_eal_alarm_init sets rte_errno on failure. */
+rte_fbarray_cloonix_biglock_off();
+KERR("ERROR EAL");
 		return -1;
 	}
 
@@ -1057,6 +1099,8 @@
 		rte_eal_init_alert("failed to init mp channel");
 		if (rte_eal_process_type() == RTE_PROC_PRIMARY) {
 			rte_errno = EFAULT;
+rte_fbarray_cloonix_biglock_off();
+KERR("ERROR EAL");
 			return -1;
 		}
 	}
@@ -1064,6 +1108,8 @@
 	/* register multi-process action callbacks for hotplug */
 	if (eal_mp_dev_hotplug_init() < 0) {
 		rte_eal_init_alert("failed to register mp callback for hotplug");
+rte_fbarray_cloonix_biglock_off();
+KERR("ERROR EAL");
 		return -1;
 	}
 
@@ -1071,6 +1117,8 @@
 		rte_eal_init_alert("Cannot scan the buses for devices");
 		rte_errno = ENODEV;
 		__atomic_store_n(&run_once, 0, __ATOMIC_RELAXED);
+rte_fbarray_cloonix_biglock_off();
+KERR("ERROR EAL");
 		return -1;
 	}
 
@@ -1130,6 +1178,8 @@
 	if (rte_eal_iova_mode() == RTE_IOVA_PA && !phys_addrs) {
 		rte_eal_init_alert("Cannot use IOVA as 'PA' since physical addresses are not available");
 		rte_errno = EINVAL;
+rte_fbarray_cloonix_biglock_off();
+KERR("ERROR EAL");
 		return -1;
 	}
 
@@ -1145,6 +1195,8 @@
 			rte_eal_init_alert("Cannot get hugepage information.");
 			rte_errno = EACCES;
 			__atomic_store_n(&run_once, 0, __ATOMIC_RELAXED);
+rte_fbarray_cloonix_biglock_off();
+KERR("ERROR EAL");
 			return -1;
 		}
 	}
@@ -1169,6 +1221,8 @@
 		rte_eal_init_alert("Cannot init logging.");
 		rte_errno = ENOMEM;
 		__atomic_store_n(&run_once, 0, __ATOMIC_RELAXED);
+rte_fbarray_cloonix_biglock_off();
+KERR("ERROR EAL");
 		return -1;
 	}
 
@@ -1177,6 +1231,8 @@
 		rte_eal_init_alert("Cannot init VFIO");
 		rte_errno = EAGAIN;
 		__atomic_store_n(&run_once, 0, __ATOMIC_RELAXED);
+rte_fbarray_cloonix_biglock_off();
+KERR("ERROR EAL");
 		return -1;
 	}
 #endif
@@ -1187,21 +1243,26 @@
 	if (rte_eal_memzone_init() < 0) {
 		rte_eal_init_alert("Cannot init memzone");
 		rte_errno = ENODEV;
+rte_fbarray_cloonix_biglock_off();
+KERR("ERROR EAL");
 		return -1;
 	}
 
 	if (rte_eal_memory_init() < 0) {
 		rte_eal_init_alert("Cannot init memory");
 		rte_errno = ENOMEM;
+rte_fbarray_cloonix_biglock_off();
+KERR("ERROR EAL");
 		return -1;
 	}
 
 	/* the directories are locked during eal_hugepage_info_init */
 	eal_hugedirs_unlock();
-
 	if (rte_eal_malloc_heap_init() < 0) {
 		rte_eal_init_alert("Cannot init malloc heap");
 		rte_errno = ENODEV;
+rte_fbarray_cloonix_biglock_off();
+KERR("ERROR EAL");
 		return -1;
 	}
 
@@ -1214,6 +1275,8 @@
 	if (rte_eal_timer_init() < 0) {
 		rte_eal_init_alert("Cannot init HPET or TSC timers");
 		rte_errno = ENOTSUP;
+rte_fbarray_cloonix_biglock_off();
+KERR("ERROR EAL");
 		return -1;
 	}
 
@@ -1223,6 +1286,8 @@
 			&lcore_config[config->main_lcore].cpuset) != 0) {
 		rte_eal_init_alert("Cannot set affinity");
 		rte_errno = EINVAL;
+rte_fbarray_cloonix_biglock_off();
+KERR("ERROR EAL");
 		return -1;
 	}
 	__rte_thread_init(config->main_lcore,
@@ -1279,6 +1344,8 @@
 	if (ret) {
 		rte_eal_init_alert("rte_service_init() failed");
 		rte_errno = -ret;
+rte_fbarray_cloonix_biglock_off();
+KERR("ERROR EAL");
 		return -1;
 	}
 
@@ -1286,13 +1353,19 @@
 	if (rte_bus_probe()) {
 		rte_eal_init_alert("Cannot probe devices");
 		rte_errno = ENOTSUP;
+rte_fbarray_cloonix_biglock_off();
+KERR("ERROR EAL");
 		return -1;
 	}
 
 #ifdef VFIO_PRESENT
 	/* Register mp action after probe() so that we got enough info */
 	if (rte_vfio_is_enabled("vfio") && vfio_mp_sync_setup() < 0)
+                {
+rte_fbarray_cloonix_biglock_off();
+KERR("ERROR EAL");
 		return -1;
+                }
 #endif
 
 	/* initialize default service/lcore mappings and start running. Ignore
@@ -1301,6 +1374,8 @@
 	ret = rte_service_start_with_defaults();
 	if (ret < 0 && ret != -ENOTSUP) {
 		rte_errno = -ret;
+rte_fbarray_cloonix_biglock_off();
+KERR("ERROR EAL");
 		return -1;
 	}
 
@@ -1316,6 +1391,8 @@
 	 */
 	if (!internal_conf->no_shconf && eal_clean_runtime_dir() < 0) {
 		rte_eal_init_alert("Cannot clear runtime directory");
+rte_fbarray_cloonix_biglock_off();
+KERR("ERROR EAL");
 		return -1;
 	}
 	if (rte_eal_process_type() == RTE_PROC_PRIMARY && !internal_conf->no_telemetry) {
@@ -1326,11 +1403,16 @@
 		if (rte_telemetry_init(rte_eal_get_runtime_dir(),
 				rte_version(),
 				&internal_conf->ctrl_cpuset, rte_log, tlog) != 0)
+                        {
+rte_fbarray_cloonix_biglock_off();
+KERR("ERROR EAL");
 			return -1;
+                        }
 	}
 
 	eal_mcfg_complete();
 
+rte_fbarray_cloonix_biglock_off();
 	return fctret;
 }
 
diff -Naur dpdk/lib/eal/linux/eal_interrupts.c dpdk_tainted/lib/eal/linux/eal_interrupts.c
--- dpdk/lib/eal/linux/eal_interrupts.c	2021-12-23 19:26:29.000000000 +0100
+++ dpdk_tainted/lib/eal/linux/eal_interrupts.c	2021-12-24 12:12:06.871226686 +0100
@@ -1168,7 +1168,9 @@
 		}
 		rte_spinlock_unlock(&intr_lock);
 		/* serve the interrupt */
+rte_fbarray_cloonix_biglock_on(__FUNCTION__, __LINE__);
 		eal_intr_handle_interrupts(pfd, numfds);
+rte_fbarray_cloonix_biglock_off();
 
 		/**
 		 * when we return, we need to rebuild the
diff -Naur dpdk/lib/eal/version.map dpdk_tainted/lib/eal/version.map
--- dpdk/lib/eal/version.map	2021-12-23 19:26:29.000000000 +0100
+++ dpdk_tainted/lib/eal/version.map	2021-12-24 12:12:06.871226686 +0100
@@ -100,6 +100,9 @@
 	rte_fbarray_is_used;
 	rte_fbarray_set_free;
 	rte_fbarray_set_used;
+        rte_fbarray_cloonix_biglock_test;
+        rte_fbarray_cloonix_biglock_on;
+        rte_fbarray_cloonix_biglock_off;
 	rte_free;
 	rte_get_hpet_cycles; # WINDOWS_NO_EXPORT
 	rte_get_hpet_hz; # WINDOWS_NO_EXPORT
diff -Naur dpdk/lib/meson.build dpdk_tainted/lib/meson.build
--- dpdk/lib/meson.build	2021-12-23 19:26:29.000000000 +0100
+++ dpdk_tainted/lib/meson.build	2021-12-24 12:12:06.871226686 +0100
@@ -92,6 +92,7 @@
 
 
 default_cflags = machine_args
+default_cflags += ['-g']
 default_cflags += ['-DALLOW_EXPERIMENTAL_API']
 default_cflags += ['-DALLOW_INTERNAL_API']
 
@@ -179,6 +180,7 @@
             c_args: cflags,
             dependencies: static_deps,
             include_directories: includes,
+            install_rpath : '/usr/local/bin/cloonix/server/dpdk/lib',
             install: true)
     static_dep = declare_dependency(
             include_directories: includes,
@@ -243,6 +245,7 @@
             link_depends: lk_deps,
             version: abi_version,
             soversion: so_version,
+            install_rpath : '/usr/local/bin/cloonix/server/dpdk/lib',
             install: true)
     shared_dep = declare_dependency(link_with: shared_lib,
             include_directories: includes,
diff -Naur dpdk/meson_options.txt dpdk_tainted/meson_options.txt
--- dpdk/meson_options.txt	2021-12-23 19:26:29.000000000 +0100
+++ dpdk_tainted/meson_options.txt	2021-12-24 12:12:06.871226686 +0100
@@ -32,7 +32,7 @@
        'Path to the kernel for building kernel modules. Headers must be in $kernel_dir or $kernel_dir/build. Modules will be installed in /lib/modules.')
 option('machine', type: 'string', value: 'auto', description:
        'Alias of cpu_instruction_set.')
-option('max_ethports', type: 'integer', value: 32, description:
+option('max_ethports', type: 'integer', value: 255, description:
        'maximum number of Ethernet devices')
 option('max_lcores', type: 'string', value: 'default', description:
        'Set maximum number of cores/threads supported by EAL; "default" is different per-arch, "detect" detects the number of cores on the build machine.')
