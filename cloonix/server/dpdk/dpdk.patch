diff -Naur dpdk/buildtools/gen-pmdinfo-cfile.py dpdk_tainted/buildtools/gen-pmdinfo-cfile.py
--- dpdk/buildtools/gen-pmdinfo-cfile.py	2021-10-17 13:34:13.000000000 +0200
+++ dpdk_tainted/buildtools/gen-pmdinfo-cfile.py	2021-10-29 22:49:53.921109585 +0200
@@ -14,7 +14,7 @@
         stdout=subprocess.PIPE, check=True, cwd=temp
     )
     # Don't use "ar p", because its output is corrupted on Windows.
-    run_ar("x")
+    run_ar("t")
     names = run_ar("t").stdout.decode().splitlines()
     paths = [os.path.join(temp, name) for name in names]
     subprocess.run(pmdinfogen + paths + [output], check=True)
diff -Naur dpdk/drivers/meson.build dpdk_tainted/drivers/meson.build
--- dpdk/drivers/meson.build	2021-10-17 13:34:13.000000000 +0200
+++ dpdk_tainted/drivers/meson.build	2021-10-29 22:49:53.921109585 +0200
@@ -162,6 +162,7 @@
         tmp_lib = static_library('tmp_' + lib_name, sources,
                 include_directories: includes,
                 dependencies: static_deps,
+                install_rpath : '/usr/local/bin/cloonix/server/dpdk/lib',
                 c_args: cflags)
         objs += tmp_lib.extract_all_objects(recursive: true)
         sources = custom_target(out_filename,
@@ -226,6 +227,7 @@
                 version: abi_version,
                 soversion: so_version,
                 install: true,
+                install_rpath : '/usr/local/bin/cloonix/server/dpdk/lib',
                 install_dir: driver_install_path)
 
         # create a dependency object and add it to the global dictionary so
diff -Naur dpdk/drivers/net/virtio/virtio_user/vhost.h dpdk_tainted/drivers/net/virtio/virtio_user/vhost.h
--- dpdk/drivers/net/virtio/virtio_user/vhost.h	2021-10-17 13:34:13.000000000 +0200
+++ dpdk_tainted/drivers/net/virtio/virtio_user/vhost.h	2021-10-29 22:49:53.921109585 +0200
@@ -15,6 +15,26 @@
 #include "../virtio_logs.h"
 #include "../virtqueue.h"
 
+#include <syslog.h>
+#include <sys/syscall.h>
+#include <bits/time.h>
+
+
+
+/*****************************************************************************/
+long long cloonix_get_usec(void);
+/*---------------------------------------------------------------------------*/
+#define KERR(format, a...)                               \
+ do {                                                    \
+    syslog(LOG_ERR | LOG_USER, "%lld %s"                 \
+    " line:%d " format "\n", cloonix_get_usec(),          \
+    (strrchr(__FILE__, '/') ? strrchr(__FILE__, '/') + 1 : __FILE__), \
+     __LINE__, ## a);                                    \
+    } while (0)
+/*---------------------------------------------------------------------------*/
+
+
+
 struct vhost_vring_state {
 	unsigned int index;
 	unsigned int num;
diff -Naur dpdk/drivers/net/virtio/virtio_user/vhost_user.c dpdk_tainted/drivers/net/virtio/virtio_user/vhost_user.c
--- dpdk/drivers/net/virtio/virtio_user/vhost_user.c	2021-10-17 13:34:13.000000000 +0200
+++ dpdk_tainted/drivers/net/virtio/virtio_user/vhost_user.c	2021-10-29 22:49:53.921109585 +0200
@@ -104,6 +104,23 @@
 #define VHOST_USER_PAYLOAD_SIZE \
 	(sizeof(struct vhost_user_msg) - VHOST_USER_HDR_SIZE)
 
+
+
+/*****************************************************************************/
+long long cloonix_get_usec(void)
+{
+  struct timespec ts;
+  long long result;
+  if (syscall(SYS_clock_gettime, CLOCK_MONOTONIC, &ts))
+    syslog(LOG_ERR | LOG_USER, "ERROR CLOCK_MONOTONIC");
+  result = (long long) (ts.tv_sec);
+  result *= 1000000;
+  result += ts.tv_nsec / 1000;
+  return result;
+}
+/*---------------------------------------------------------------------------*/
+
+
 static int
 vhost_user_write(int fd, struct vhost_user_msg *msg, int *fds, int fd_num)
 {
@@ -147,7 +164,10 @@
 	uint32_t valid_flags = VHOST_USER_REPLY_MASK | VHOST_USER_VERSION;
 	int ret, sz_hdr = VHOST_USER_HDR_SIZE, sz_payload;
 
+//cloonix TOLOOKAT
+//KERR("BEFORE RECV vhost_user_read pid:%d", getpid());
 	ret = recv(fd, (void *)msg, sz_hdr, 0);
+//KERR("AFTER RECV vhost_user_read ret:%d", ret);
 	if (ret < 0) {
 		PMD_DRV_LOG(ERR, "Failed to recv msg header: %s", strerror(errno));
 		return -1;
@@ -173,7 +193,10 @@
 	}
 
 	if (sz_payload) {
+//cloonix TOLOOKAT
+//KERR("BEFORE RECV vhost_user_read pid:%d", getpid());
 		ret = recv(fd, (void *)((char *)msg + sz_hdr), sz_payload, 0);
+//KERR("AFTER RECV vhost_user_read ret:%d", ret);
 		if (ret < 0) {
 			PMD_DRV_LOG(ERR, "Failed to recv msg payload: %s", strerror(errno));
 			return -1;
@@ -513,6 +536,8 @@
 		.payload.state = *state,
 	};
 
+//cloonix TOLOOKAT
+//KERR("BEFORE WRITE vhost_user_set_vring pid:%d", getpid());
 	ret = vhost_user_write(data->vhostfd, &msg, NULL, 0);
 	if (ret < 0) {
 		PMD_DRV_LOG(ERR, "Failed to set vring state (request %d)", req);
@@ -525,6 +550,8 @@
 static int
 vhost_user_set_vring_enable(struct virtio_user_dev *dev, struct vhost_vring_state *state)
 {
+//cloonix TOLOOKAT
+//KERR("BEFORE WRITE vhost_user_set_vringenable pid:%d", getpid());
 	return vhost_user_set_vring(dev, VHOST_USER_SET_VRING_ENABLE, state);
 }
 
diff -Naur dpdk/drivers/net/virtio/virtio_user/virtio_user_dev.c dpdk_tainted/drivers/net/virtio/virtio_user/virtio_user_dev.c
--- dpdk/drivers/net/virtio/virtio_user/virtio_user_dev.c	2021-10-17 13:34:13.000000000 +0200
+++ dpdk_tainted/drivers/net/virtio/virtio_user/virtio_user_dev.c	2021-10-29 22:49:53.921109585 +0200
@@ -23,6 +23,7 @@
 
 #define VIRTIO_USER_MEM_EVENT_CLB_NAME "virtio_user_mem_event_clb"
 
+
 const char * const virtio_user_backend_strings[] = {
 	[VIRTIO_USER_BACKEND_UNKNOWN] = "VIRTIO_USER_BACKEND_UNKNOWN",
 	[VIRTIO_USER_BACKEND_VHOST_USER] = "VHOST_USER",
@@ -327,8 +328,11 @@
 	} else {
 		ret = virtio_user_dev_get_mac(dev);
 		if (ret) {
+/*
+cloonix
 			PMD_DRV_LOG(ERR, "(%s) No valid MAC in devargs or device, use random",
 					dev->path);
+*/
 			return;
 		}
 
@@ -443,6 +447,8 @@
 	if (msl->external)
 		return;
 
+//cloonix TOLOOKAT
+KERR("ERROR TOLOOKAT MAY DEADLOCK pid:%d", getpid());
 	pthread_mutex_lock(&dev->mutex);
 
 	if (dev->started == false)
diff -Naur dpdk/lib/eal/common/eal_common_devargs.c dpdk_tainted/lib/eal/common/eal_common_devargs.c
--- dpdk/lib/eal/common/eal_common_devargs.c	2021-10-17 13:34:14.000000000 +0200
+++ dpdk_tainted/lib/eal/common/eal_common_devargs.c	2021-10-29 22:49:53.921109585 +0200
@@ -88,8 +88,11 @@
 	/* Split each sub-lists. */
 	nblayer = devargs_layer_count(devstr);
 	if (nblayer > RTE_DIM(layers)) {
+/*
+cloonix 
 		RTE_LOG(ERR, EAL, "Invalid format: too many layers (%zu)\n",
 			nblayer);
+*/
 		ret = -E2BIG;
 		goto get_out;
 	}
diff -Naur dpdk/lib/eal/common/eal_common_options.c dpdk_tainted/lib/eal/common/eal_common_options.c
--- dpdk/lib/eal/common/eal_common_options.c	2021-10-17 13:34:14.000000000 +0200
+++ dpdk_tainted/lib/eal/common/eal_common_options.c	2021-10-29 22:49:53.921109585 +0200
@@ -125,7 +125,9 @@
 
 #ifndef RTE_EXEC_ENV_WINDOWS
 /* Default path of external loadable drivers */
-static const char *default_solib_dir = RTE_EAL_PMD_PATH;
+//static const char *default_solib_dir = RTE_EAL_PMD_PATH;
+static const char *default_solib_dir = "/usr/local/bin/cloonix/server/dpdk/lib";
+
 #endif
 
 /*
diff -Naur dpdk/lib/eal/linux/eal.c dpdk_tainted/lib/eal/linux/eal.c
--- dpdk/lib/eal/linux/eal.c	2021-10-17 13:34:14.000000000 +0200
+++ dpdk_tainted/lib/eal/linux/eal.c	2021-10-29 22:49:53.921109585 +0200
@@ -27,6 +27,7 @@
 #endif
 #include <linux/version.h>
 
+
 #include <rte_compat.h>
 #include <rte_common.h>
 #include <rte_debug.h>
@@ -93,18 +94,17 @@
 {
 	const char *directory = default_runtime_dir;
 	const char *xdg_runtime_dir = getenv("XDG_RUNTIME_DIR");
-	const char *fallback = "/tmp";
 	char run_dir[PATH_MAX];
 	char tmp[PATH_MAX];
-	int ret;
+	int ret, err;
+        struct stat s;
 
-	if (getuid() != 0) {
-		/* try XDG path first, fall back to /tmp */
-		if (xdg_runtime_dir != NULL)
-			directory = xdg_runtime_dir;
-		else
-			directory = fallback;
-	}
+	if (xdg_runtime_dir != NULL)
+		directory = xdg_runtime_dir;
+	else {
+                syslog(LOG_ERR | LOG_USER, "xdg_runtime_dir NOT DEFINED\n");
+		return -1;
+        }
 	/* create DPDK subdirectory under runtime dir */
 	ret = snprintf(tmp, sizeof(tmp), "%s/dpdk", directory);
 	if (ret < 0 || ret == sizeof(tmp)) {
@@ -123,19 +123,47 @@
 	/* create the path if it doesn't exist. no "mkdir -p" here, so do it
 	 * step by step.
 	 */
-	ret = mkdir(tmp, 0700);
-	if (ret < 0 && errno != EEXIST) {
-		RTE_LOG(ERR, EAL, "Error creating '%s': %s\n",
-			tmp, strerror(errno));
-		return -1;
-	}
-
-	ret = mkdir(run_dir, 0700);
-	if (ret < 0 && errno != EEXIST) {
-		RTE_LOG(ERR, EAL, "Error creating '%s': %s\n",
-			run_dir, strerror(errno));
-		return -1;
-	}
+        err = stat(tmp, &s);
+        if(-1 == err) {
+            if(ENOENT == errno) {
+	        ret = mkdir(tmp, 0700);
+	        if (ret < 0 && errno != EEXIST) {
+                    syslog(LOG_ERR | LOG_USER, "MKDIR ERROR %s %s\n",
+                           tmp, strerror(errno));
+		return -1;
+	        }
+            } else {
+                syslog(LOG_ERR | LOG_USER, "STAT ERROR %s %s %d\n",
+                       tmp, strerror(errno), getuid());
+    	        return -1;
+            }
+        } else {
+            if(S_ISDIR(s.st_mode) == 0) {
+                syslog(LOG_ERR | LOG_USER, "NOT A DIR ERROR %s\n", tmp);
+    	        return -1;
+            }
+        }
+
+        err = stat(run_dir, &s);
+        if(-1 == err) {
+            if(ENOENT == errno) {
+	        ret = mkdir(run_dir, 0700);
+                if (ret < 0 && errno != EEXIST) {
+                    syslog(LOG_ERR | LOG_USER, "MKDIR ERROR %s %s\n", 
+                           run_dir, strerror(errno));
+                return -1;
+                }
+            } else {
+                syslog(LOG_ERR | LOG_USER, "STAT ERROR %s %s %d\n",
+                       run_dir, strerror(errno), getuid());
+                return -1;
+            }
+        } else {
+            if(S_ISDIR(s.st_mode) == 0) {
+                syslog(LOG_ERR | LOG_USER, "NOT A DIR ERROR %s\n", run_dir);
+                return -1;
+            }
+        }
 
 	if (eal_set_runtime_dir(run_dir, sizeof(run_dir)))
 		return -1;
@@ -359,14 +387,13 @@
 {
 	struct rte_config *config = rte_eal_get_configuration();
 	struct rte_mem_config *mem_config;
-	const struct internal_config *internal_conf =
-		eal_get_internal_configuration();
-
-	const char *pathname = eal_runtime_config_path();
+	const struct internal_config *internal_conf;
+	const char *pathname;
 
+	internal_conf = eal_get_internal_configuration();
+	pathname = eal_runtime_config_path();
 	if (internal_conf->no_shconf)
 		return 0;
-
 	if (mem_cfg_fd < 0){
 		mem_cfg_fd = open(pathname, O_RDWR);
 		if (mem_cfg_fd < 0) {
@@ -471,27 +498,34 @@
 rte_config_init(void)
 {
 	struct rte_config *config = rte_eal_get_configuration();
-	const struct internal_config *internal_conf =
-		eal_get_internal_configuration();
+	const struct internal_config *internal_conf;
 
+	internal_conf =	eal_get_internal_configuration();
 	config->process_type = internal_conf->process_type;
 
 	switch (config->process_type) {
 	case RTE_PROC_PRIMARY:
 		if (rte_eal_config_create() < 0)
-			return -1;
+                    {
+		    return -1;
+                    }
+
 		eal_mcfg_update_from_internal();
 		break;
 	case RTE_PROC_SECONDARY:
+
 		if (rte_eal_config_attach() < 0)
-			return -1;
+                    {
+		    return -1;
+                    }
 		eal_mcfg_wait_complete();
 		if (eal_mcfg_check_version() < 0) {
 			RTE_LOG(ERR, EAL, "Primary and secondary process DPDK version mismatch\n");
 			return -1;
 		}
-		if (rte_eal_config_reattach() < 0)
+		if (rte_eal_config_reattach() < 0) {
 			return -1;
+                }
 		if (!__rte_mp_enable()) {
 			RTE_LOG(ERR, EAL, "Primary process refused secondary attachment\n");
 			return -1;
@@ -931,6 +965,7 @@
 {
 	fprintf(stderr, "EAL: FATAL: %s\n", msg);
 	RTE_LOG(ERR, EAL, "%s\n", msg);
+        syslog(LOG_ERR | LOG_USER, "%s\n", msg);
 }
 
 /*
@@ -1079,6 +1114,10 @@
 	phys_addrs = rte_eal_using_phys_addrs() != 0;
 
 	/* if no EAL option "--iova-mode=<pa|va>", use bus IOVA scheme */
+
+//VIP
+	internal_conf->iova_mode = RTE_IOVA_VA;
+
 	if (internal_conf->iova_mode == RTE_IOVA_DC) {
 		/* autodetect the IOVA mapping mode */
 		enum rte_iova_mode iova_mode = rte_bus_get_iommu_class();
diff -Naur dpdk/lib/meson.build dpdk_tainted/lib/meson.build
--- dpdk/lib/meson.build	2021-10-17 13:34:14.000000000 +0200
+++ dpdk_tainted/lib/meson.build	2021-10-29 22:52:35.201721127 +0200
@@ -110,6 +110,7 @@
 
 
 default_cflags = machine_args
+default_cflags += ['-g']
 default_cflags += ['-DALLOW_EXPERIMENTAL_API']
 default_cflags += ['-DALLOW_INTERNAL_API']
 
@@ -197,6 +198,7 @@
             c_args: cflags,
             dependencies: static_deps,
             include_directories: includes,
+            install_rpath : '/usr/local/bin/cloonix/server/dpdk/lib',
             install: true)
     static_dep = declare_dependency(
             include_directories: includes,
@@ -261,6 +263,7 @@
             link_depends: lk_deps,
             version: abi_version,
             soversion: so_version,
+            install_rpath : '/usr/local/bin/cloonix/server/dpdk/lib',
             install: true)
     shared_dep = declare_dependency(link_with: shared_lib,
             include_directories: includes,
diff -Naur dpdk/meson_options.txt dpdk_tainted/meson_options.txt
--- dpdk/meson_options.txt	2021-10-17 13:34:14.000000000 +0200
+++ dpdk_tainted/meson_options.txt	2021-10-29 22:49:53.921109585 +0200
@@ -32,7 +32,7 @@
        'Path to the kernel for building kernel modules. Headers must be in $kernel_dir or $kernel_dir/build. Modules will be installed in /lib/modules.')
 option('machine', type: 'string', value: 'auto', description:
        'Alias of cpu_instruction_set.')
-option('max_ethports', type: 'integer', value: 32, description:
+option('max_ethports', type: 'integer', value: 255, description:
        'maximum number of Ethernet devices')
 option('max_lcores', type: 'string', value: 'default', description:
        'Set maximum number of cores/threads supported by EAL; "default" is different per-arch, "detect" detects the number of cores on the build machine.')
